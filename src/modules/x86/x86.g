/*
 *   Copyright (C) 2003-2006 by Thiago Silva                               *
 *   thiago.silva@kdemal.net                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                           */
header {
  #include "PortugolAST.hpp"
  #include "SymbolTable.hpp"
  #include <string>
  #include <sstream>
//   #include <map>
//   #include <list>
  using namespace std;
}

options {
  language="Cpp";
}

class X86Walker extends TreeParser;
options {
  importVocab=Portugol;  // use vocab generated by lexer
  ASTLabelType="RefPortugolAST";
  noConstructors=true;
  genHashLines=false;//no #line
}

{
  public:
  X86Walker(SymbolTable& st) 
    : stable(st), _currentScope("@global"), indent("        ") { }

  private:

  void init(string name) {
    head << "; algoritmo: " << name << "\n\n";

    #include <asm_tmpl.h>

    bss << "section .bss\n"
           "    __mem    resb  __MEMORY_SIZE\n\n";

    data << "section .data\n"
            "    __mem_ptr   dd 0\n"
            "    __aux       dd 0\n"
            "    __str_true  db 'verdadeiro',0\n"
            "    __str_false db 'falso',0\n"
            "    __str_no_mem_left db 'Não foi possível alocar memória.',0\n\n";


    txt << "section .text" << endl;    
  }

  void declarePrimitive(bool isGlobal, int type, string name) {
    if(isGlobal) {
      switch(type) {
        case TIPO_INTEIRO:
          data << name << " dd 0" << endl;
          break;
        case TIPO_REAL:
          data << name << " dd 0" << endl;
          break;
        case TIPO_CARACTERE:
          data << name << " dd 0" << endl;
          break;
        case TIPO_LITERAL:
          data << name << " dd 0" << endl;
          break;
        case TIPO_LOGICO:
          data << name << " dd 0" << endl;
          break;
        default:
          cerr << "Erro interno: tipo nao suportado (x86::declarePrimitive)." << endl;
          exit(1);
      }    
    } else {
      //TODO
    }
  }

  void declareMatrix(bool isGlobal, int type, string name, list<string> dims) {
    int size = 1;
    for(list<string>::iterator it = dims.begin(); it != dims.end(); it++) {
      size *= atoi((*it).c_str());
    }

    if(isGlobal) {
      switch(type) {
        case TIPO_INTEIRO:
          data << name << " times " << size << " dd 0" << endl;
          break;
        case TIPO_REAL:
          data << name << " times " << size << " dd 0" << endl;
          break;
        case TIPO_CARACTERE:
          data << name << " times " << size << " dd 0" << endl;
          break;
        case TIPO_LITERAL:
          data << name << " times " << size << " db 0" << endl;
          break;
        case TIPO_LOGICO:
          data << name << " times " << size << " dd 0" << endl;
          break;
        default:
          cerr << "Erro interno: tipo nao suportado (x86::declareMatrix)." << endl;
          exit(1);
      }    
    } else {
      //TODO
    }
  }

  string createLabel(bool local, string tmpl) {
    static int c = 0;
    stringstream s;
    if(local) {
      s << ".___" << tmpl << "_" << c;
    } else {
      s << "." << tmpl << "_" << c;
    }
    c++;
    return s.str();
  }

  string insertString(string str) {
    string lb = createLabel(false, "str");
    data << lb << " db '" << str << "',0" << endl;
    return lb;
  }

  string translateFuncLeia(const string& id, int type) {
    switch(type) {
      case TIPO_REAL:
        return "__leia_real";
      case TIPO_LITERAL:
        return "__leia_literal";
      case TIPO_CARACTERE:
        return "__leia_caractere";
      case TIPO_LOGICO:
        return "__leia_logico";
      case TIPO_INTEIRO:
      default:
        return "__leia_inteiro";
    }
  }

  string translateFuncImprima(const string& id, int type) {
    switch(type) {
      case TIPO_REAL:
        return "__imprima_real";
      case TIPO_LITERAL:
        return "__imprima_literal";
      case TIPO_CARACTERE:
        return "__imprima_caractere";
      case TIPO_LOGICO:
        return "__imprima_logico";
      case TIPO_INTEIRO:
        return "__imprima_inteiro";
      default:
        cerr << "Erro interno: tipo nao suportado (x86::translateFuncImprima)." << endl;
        exit(1);
    }
  }
  
  void writeln(string str) {    
    txt << indent << str << endl;
  }

  void writeFooter() {
    txt << "exit 0\n";    
  }

  SymbolTable& stable;
  string _currentScope;

  string indent;
  stringstream head;
  stringstream bss;
  stringstream data;  
  stringstream txt;
  stringstream lib;

  
  
}

/********************************* Producoes **************************************/

algoritmo returns [string str]
  : #(T_KW_ALGORITMO id:T_IDENTIFICADOR) {init(id->getText());}
    (variaveis[true])? 
     principal
//     (func_decls)*

  {
    str =  head.str();
    str += bss.str();
    str += data.str();     
    str += txt.str();
    str += lib.str();
  }
  ;

variaveis[bool isGlobal]
  : #(T_KW_VARIAVEIS (primitivo[isGlobal] | matriz[isGlobal])+ )
  ;

primitivo[bool isGlobal]
{
  int type;
  stringstream str;
}
  : #(TI_VAR_PRIMITIVE type=tipo_prim
      (
        id:T_IDENTIFICADOR
        {declarePrimitive(isGlobal, type, id->getText());}
      )+
    )
  ;

tipo_prim returns [int t]
  : T_KW_INTEIRO   {t = TIPO_INTEIRO;}
  | T_KW_REAL      {t = TIPO_REAL;}
  | T_KW_CARACTERE {t = TIPO_CARACTERE;}
  | T_KW_LITERAL   {t = TIPO_LITERAL;}
  | T_KW_LOGICO    {t = TIPO_LOGICO;}
  ;

matriz[bool isGlobal]
{
  pair<int, list<string> > tp;
}
  : #(TI_VAR_MATRIX tp=tipo_matriz 
      (
        id:T_IDENTIFICADOR
        {declareMatrix(isGlobal, tp.first, id->getText(), tp.second);}
      )+
    )
  ;


tipo_matriz returns [pair<int, list<string> > p] //pair<type, list<dimsize> >
  : #(T_KW_INTEIROS 
      {p.first = TIPO_INTEIRO;}
      (
        s1:T_INT_LIT
        {p.second.push_back(s1->getText());}
      )+
    )
  | #(T_KW_REAIS
      {p.first = TIPO_REAL;}
      (
        s2:T_INT_LIT
        {p.second.push_back(s2->getText());}
      )+
    )
  | #(T_KW_CARACTERES
      {p.first = TIPO_CARACTERE;}
      (
        s3:T_INT_LIT
        {p.second.push_back(s3->getText());}
      )+
    )
  | #(T_KW_LITERAIS
      {p.first = TIPO_LITERAL;}
      (
        s4:T_INT_LIT
        {p.second.push_back(s4->getText());}
      )+
    )
  | #(T_KW_LOGICOS
      {p.first = TIPO_LOGICO;}
      (
        s5:T_INT_LIT
        {p.second.push_back(s5->getText());}
      )+
    )
  ;

principal
{
  writeln("_start:");
  writeln("_start_no equ $");
}
  : stm_block
{writeFooter();}
  ;

stm_block
  : #(T_KW_INICIO (stm)* )
  ;

stm
{int t;}
  : stm_attr
  | t=fcall[TIPO_ALL]
//   | stm_ret
//   | stm_se
//   | stm_enquanto
//   | stm_para
  ;

stm_attr
{
  pair<int, string> lv;
  int expecting_type;
  int etype;
  stringstream s;

  writeln("; atribuicao");
}
  : #(T_ATTR lv=lvalue
      {
        expecting_type = stable.getSymbol(_currentScope, lv.second, true).type.primitiveType();
      }

      etype=expr[expecting_type]
		)

    {
      //casts
      if((etype != TIPO_REAL) && (expecting_type == TIPO_REAL)) {
        //int to float
        writeln("mov dword [__aux], eax");
        writeln("fild dword [__aux]");
        writeln("fstp dword [__aux]");
        writeln("mov eax, dword [__aux]");
      } else if((etype == TIPO_REAL) && (expecting_type != TIPO_REAL)) {
        writeln("mov dword [__aux], eax");
        writeln("fld dword [__aux]");
        writeln("fistp dword [__aux]");
        writeln("mov eax, dword [__aux]");
      }
      s << "mov [" << lv.second << "], eax";
      writeln(s.str());
    }
  ;

lvalue returns [pair<int, string> p]
{
  list<int> dims;
  list<int>::iterator it = dims.begin();

  unsigned int c = 1;
  stringstream s;

  Symbol symb;
}
  : #(id:T_IDENTIFICADOR
      {
        symb = stable.getSymbol(_currentScope, id->getText(), true);
        p.first = symb.type.primitiveType();
        p.second = id->getText();
        
        dims = symb.type.dimensions();

        if(dims.size() > 0) {
          writeln("push eax");
          writeln("mov edx, 1");
          writeln("push edx");
        } else {
//           writeln("mov edx, 0");
        }
      }

      (
        expr[TIPO_INTEIRO]
        {
          writeln("pop edx");

          if(c == dims.size()) {
            if(dims.size() == 1) {
              writeln("mov edx, eax");
            } else {
              writeln("add edx, eax");
            }
          } else {
            s << "mul edx, " << *it;
            writeln(s.str());
          }

          writeln("push edx");
          c++;
          it++;
        }
      )*

      {
/*        if(dims.size() > 0) {
          writeln("pop edx");
          writeln("pop eax");
        }*/
      }
    )
  ;

fcall[int expct_type] returns [int type]
{
  Symbol f;
  int count = 0;

  stringstream s;
  string fname, fimp;
  int args = 0;
  int etype;
  int ptype;
}
  : #(TI_FCALL id:T_IDENTIFICADOR 
      {
        f = stable.getSymbol(SymbolTable::GlobalScope, id->getText()); //so we get the params        
        type = f.type.primitiveType();
        if(f.lexeme == "leia") {
          fname = translateFuncLeia(id->getText(), expct_type);
        } else {
          fname = f.lexeme;
        }
        ptype = f.param.paramType(count++);
      }
      (
        etype=expr[ptype]
        {
          if(fname == "imprima") {
            fimp = translateFuncImprima(id->getText(), etype);

            writeln("addarg eax");
            writeln(string("call ") + fimp);
            writeln("clargs 1");
          } else {
            writeln("addarg eax");
            ptype = f.param.paramType(count++);
          }
          args++;
        }
      )*
    )
    {
      if(fname == "imprima") {
        writeln("print_lf"); //\n
      } else {
        writeln(string("call ") + fname);
        s << "clargs " << args;
        writeln(s.str());
      }
    }
  ;

/*
stm_ret
{
  int expecting_type = stable.getSymbol(SymbolTable::GlobalScope, _currentScope, true).type.primitiveType();
  production e;
  stringstream str;
}
  : #(T_KW_RETORNE (TI_NULL|e=expr[expecting_type]))
  ;
*/
stm_se
{
  stringstream s;
  string lbnext, lbfim;

  lbnext = createLabel(true, "next_se");
  lbfim = createLabel(true, "fim_se");

  bool hasElse = false;

  writeln("; se: expressao");
}
  : #(T_KW_SE expr[TIPO_LOGICO]

    {
      writeln("; se: resultado");

      writeln("cmp eax, 0");
      s << "jne " << lbnext;
      writeln(s.str());

      writeln("; se: caso verdadeiro:");
    }

      (stm)*
    (
        T_KW_SENAO

      {
        hasElse = true;

        s.str("");
        s << "jmp " << lbfim;
        writeln(s.str());

        writeln("; se: caso falso:");

        s.str("");
        s << lbnext << ":";
        writeln(s.str());
      }
        (stm)*
      )?
    )

    {
      writeln("; se: fim:");

      s.str("");
      if(hasElse) {
        s << lbfim << ":";        
      } else {
        s << lbnext << ":";
      }
      writeln(s.str());
    }
  ;

/*
stm_enquanto
{
  production e;
  stringstream str;
}
  : #(T_KW_ENQUANTO e=expr[TIPO_LOGICO]
      (stm)*
    )
  ;

stm_para
{
  bool haspasso = false;
  production de,ate, ps;
  stringstream str;
}
  : #(T_KW_PARA id:T_IDENTIFICADOR de=expr[TIPO_INTEIRO] ate=expr[TIPO_INTEIRO] (ps=passo {haspasso=true;})?
      (stm)*
    )
  ;

passo returns [production p]
{p.passo.first=true;}
  : #(T_KW_PASSO (
          T_MAIS  {p.passo.first=true;} //crescente
        | T_MENOS {p.passo.first=false;} //decrescente
        )? 
      i:T_INT_LIT {p.passo.second = i->getText();}
    )
  ;

*/

expr[int expecting_type, string reg = "eax"] returns [int etype]
{
  int e1, e2;
  stringstream s;
  etype = #expr->getEvalType();
}
  : #(T_KW_OU     e1=expr[expecting_type] e2=expr[expecting_type, "ebx"]) 
      {
        writeln("cmp eax, 0");
        writeln("setne al");
        writeln("and eax, 0xff");
        writeln("cmp ebx, 0");
        writeln("setne bl");
        writeln("and ebx, 0xff");
        writeln("or al, bl");
      }
  | #(T_KW_E      e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        writeln("cmp eax, 0");        
        writeln("setne al");
        writeln("and eax, 0xff");
        writeln("cmp ebx, 0");
        writeln("setne bl");
        writeln("and ebx, 0xff");
        writeln("and al, bl");        
      }
  | #(T_BIT_OU    e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        writeln("or eax, ebx");
      }
  | #(T_BIT_XOU   e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        writeln("xor eax, ebx");
      }
  | #(T_BIT_E     e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        writeln("and eax, ebx");
      }
  | #(T_IGUAL     e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        writeln("cmp eax, ebx");
        writeln("sete al");
        writeln("and eax, 0xff");
      }
  | #(T_DIFERENTE e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        writeln("cmp eax, ebx");
        writeln("setne al");
        writeln("and eax, 0xff");
      }
  | #(T_MAIOR     e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        //fcomp assumes ST0 is left-hand operand aways
        //flags after comp:
        //5.0 @ 4 : ax -> 0
        //5.0 @ 5 : ax -> 0x4000
        //4.0 @ 6 : ax -> 0x100
        if((e1 == TIPO_REAL) || (e2 == TIPO_REAL)) {
          writeln("fninit");
          if((e1 == TIPO_REAL) && (e2 != TIPO_REAL)) { //float/integer
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            writeln("ficomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0");
          } else if((e1 != TIPO_REAL) && (e2 == TIPO_REAL)) { //integer/float
            writeln("mov [__aux], ebx");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], eax");
            writeln("ficomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0x100");
          } else { //float/float
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            writeln("fcomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0");
          }
          writeln("sete al");
          writeln("and eax, 0xff");
        } else {
          writeln("cmp eax, ebx");
          writeln("setg al");
          writeln("and eax, 0xff");
        }
      }
  | #(T_MENOR     e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        if((e1 == TIPO_REAL) || (e2 == TIPO_REAL)) {
          writeln("fninit");
          if((e1 == TIPO_REAL) && (e2 != TIPO_REAL)) { //float/integer
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            writeln("ficomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0x100");
          } else if((e1 != TIPO_REAL) && (e2 == TIPO_REAL)) { //integer/float
            writeln("mov [__aux], ebx");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], eax");
            writeln("ficomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0");
          } else { //float/float
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            writeln("fcomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0x100");
          }
          writeln("sete al");
          writeln("and eax, 0xff");
        } else {
          writeln("cmp eax, ebx");
          writeln("setl al");
          writeln("and eax, 0xff");
        }
      }
  | #(T_MAIOR_EQ  e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        if((e1 == TIPO_REAL) || (e2 == TIPO_REAL)) {
          writeln("fninit");
          if((e1 == TIPO_REAL) && (e2 != TIPO_REAL)) { //float/integer
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            writeln("ficomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0");
          } else if((e1 != TIPO_REAL) && (e2 == TIPO_REAL)) { //integer/float
            writeln("mov [__aux], ebx");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], eax");
            writeln("ficomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0x100");
          } else { //float/float
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            writeln("fcomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0");
          }
          writeln("sete bl");
          writeln("and ebx, 0xff");
          
          writeln("cmp ax, 0x4000");
          writeln("sete al");
          writeln("and eax, 0xff");
          writeln("or eax, ebx");
        } else {
          writeln("cmp eax, ebx");
          writeln("setge al");
          writeln("and eax, 0xff");
        }
      }
  | #(T_MENOR_EQ  e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        if((e1 == TIPO_REAL) || (e2 == TIPO_REAL)) {
          writeln("fninit");
          if((e1 == TIPO_REAL) && (e2 != TIPO_REAL)) { //float/integer
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            writeln("ficomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0x100");
          } else if((e1 != TIPO_REAL) && (e2 == TIPO_REAL)) { //integer/float
            writeln("mov [__aux], ebx");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], eax");
            writeln("ficomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0");
          } else { //float/float
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            writeln("fcomp dword [__aux]");
            writeln("fstsw ax");
            writeln("cmp ax, 0x100");
          }
          writeln("sete bl");
          writeln("and ebx, 0xff");
          
          writeln("cmp ax, 0x4000");
          writeln("sete al");
          writeln("and eax, 0xff");
          writeln("or eax, ebx");
        } else {
          writeln("cmp eax, ebx");
          writeln("setle al");
          writeln("and eax, 0xff");
        }
      }
  | #(T_MAIS      e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        if((e1 == TIPO_REAL) || (e2 == TIPO_REAL)) {
          string addpop;
          writeln("fninit");
          if((e1 == TIPO_REAL) && (e2 != TIPO_REAL)) { //float/integer
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            addpop = "fiadd dword [__aux]";
          } else if((e1 != TIPO_REAL) && (e2 == TIPO_REAL)) { //integer/float
            writeln("mov [__aux], ebx");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], eax");
            addpop = "fiadd dword [__aux]";
          } else { //float/float
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            addpop = "fadd dword [__aux]";
          }
            writeln(addpop);
            writeln("fstp dword [__aux]");
            writeln("mov eax, dword [__aux]");
        } else {
          writeln("add eax, ebx");
        }
      }
  | #(T_MENOS     e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        if((e1 == TIPO_REAL) || (e2 == TIPO_REAL)) {
          string subop;
          writeln("fninit");
          if((e1 == TIPO_REAL) && (e2 != TIPO_REAL)) { //float/integer
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            subop = "fisub dword [__aux]";
          } else if((e1 != TIPO_REAL) && (e2 == TIPO_REAL)) { //integer/float
            writeln("mov [__aux], ebx");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], eax");
            subop = "fisub dword [__aux]";
          } else { //float/float
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            subop = "fsub dword [__aux]";
          }
            writeln(subop);
            writeln("fstp dword [__aux]");
            writeln("mov eax, dword [__aux]");
        } else {
          writeln("sub eax, ebx");
        }
      }
  | #(T_DIV       e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        if((e1 == TIPO_REAL) || (e2 == TIPO_REAL)) {
          string divpop;
          writeln("fninit");
          if((e1 == TIPO_REAL) && (e2 != TIPO_REAL)) { //float/integer
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            divpop = "fidiv dword [__aux]";
          } else if((e1 != TIPO_REAL) && (e2 == TIPO_REAL)) { //integer/float
            writeln("mov [__aux], ebx");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], eax");
            divpop = "fidivr dword [__aux]";
          } else { //float/float
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            divpop = "fdiv dword [__aux]";
          }
            writeln(divpop);
            writeln("fstp dword [__aux]");
            writeln("mov eax, dword [__aux]");
        } else {
          writeln("xor edx, edx");
          writeln("idiv ebx");
        }
      }
  | #(T_MULTIP    e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        if((e1 == TIPO_REAL) || (e2 == TIPO_REAL)) {
          string mulpop;
          writeln("fninit");
          if((e1 == TIPO_REAL) && (e2 != TIPO_REAL)) { //float/integer
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            mulpop = "fimul dword [__aux]";
          } else if((e1 != TIPO_REAL) && (e2 == TIPO_REAL)) { //integer/float
            writeln("mov [__aux], ebx");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], eax");
            mulpop = "fimul dword [__aux]";
          } else { //float/float
            writeln("mov [__aux], eax");
            writeln("fld dword [__aux]");
            writeln("mov [__aux], ebx");
            mulpop = "fmul dword [__aux]";
          }
            writeln(mulpop);
            writeln("fstp dword [__aux]");
            writeln("mov eax, dword [__aux]");
        } else {
          writeln("imul eax, ebx");
        }
      }
  | #(T_MOD       e1=expr[expecting_type] e2=expr[expecting_type, "ebx"])
      {
        writeln("xor edx, edx");
        writeln("idiv ebx");        
        writeln("mov eax, edx");
      }
  | #(TI_UN_NEG   etype=element[expecting_type, reg])
      {
        if(etype == TIPO_REAL) {
          s << "or " << reg << ",0x80000000";
        } else {
          s << "neg " << reg;          
        }
        writeln(s.str());
      }
  | #(TI_UN_POS   etype=element[expecting_type, reg])
      {
        //nothing
      }
  | #(TI_UN_NOT   etype=element[expecting_type, reg])
      {
        writeln("mov ebx, eax");
        writeln("xor eax, eax");
        writeln("cmp ebx, 0");
        writeln("sete al");        
      }
  | #(TI_UN_BNOT  etype=element[expecting_type, reg])
      {
        writeln("not eax");
      }
  | etype=element[expecting_type, reg]
  ;

element[int expecting_type, string reg] returns [int etype]
{
  stringstream s;
  string str;
  pair<int, string> p;
}
  : p=literal {s << "mov " << reg << ", " << p.second; writeln(s.str());etype = p.first;}
  | etype=fcall[expecting_type]
  | p=lvalue  {s << "mov " << reg << ", [" << p.second << "]"; writeln(s.str());etype = p.first;}
  | #(TI_PARENTHESIS etype=expr[expecting_type, reg])
  ;

literal returns [pair<int, string> p]
{
  stringstream ss;
}
  : s:T_STRING_LIT        {p.second = insertString(s->getText());p.first = TIPO_LITERAL;}
  | i:T_INT_LIT           {p.second = i->getText();p.first = TIPO_INTEIRO;}
  | c:T_CARAC_LIT         {ss << (int) c->getText().c_str()[0]; p.second = ss.str();p.first = TIPO_CARACTERE;}
  | v:T_KW_VERDADEIRO     {p.second = "1";p.first = TIPO_LOGICO;}
  | f:T_KW_FALSO          {p.second = "0";p.first = TIPO_LOGICO;}
  | r:T_REAL_LIT          {
                            //get the content of a float variable to integer.
                            float fvalue; //sizeof(float) should be 4
                            long  *fvaluep; //sizeof(long) should be 4
                            void *pt;
                            fvalue = atof(r->getText().c_str()); 
                            pt = &fvalue; 
                            fvaluep = (long*) pt;
                            ss << *fvaluep; 
                            p.second = ss.str();
                            p.first = TIPO_REAL;
                          }
  ;


/*
func_decls
{
  production prim;
  production mat;
  stringstream str;
  stringstream cpy;
  stringstream decl;
  string comma;
}
  : #(id:T_IDENTIFICADOR   
      {
        setScope(id->getText());
        //nota: nao estamos usando a producao "ret_type" para saber o tipo de retorno.
        //      Procuramos diretamente na tabela de simbolos. (conveniencia)
        _currentScopeType = stable.getSymbol(SymbolTable::GlobalScope, id->getText(), true).type.primitiveType();
        str << translateType(_currentScopeType);
        str << " " << id->getText() << "(";
      }

      (
          prim=primitivo
            {              
              for(list<string>::iterator it = prim.primvars.second.begin(); it != prim.primvars.second.end(); ++it) {
                str << comma << translateType(prim.primvars.first) << " " << (*it);
                comma = ", ";
              }
            }
        | mat=matriz
            {
              stringstream s;
              for(list<string>::iterator itid = mat.matrizvars.second.first.begin(); itid !=  mat.matrizvars.second.first.end(); ++itid) {
                s << comma << translateType(mat.matrizvars.first) << " " << *itid << "__";
                decl << translateType(mat.matrizvars.first) << " " << *itid;
        
                comma = ",";
                for(list<string>::iterator itdim = mat.matrizvars.second.second.begin(); itdim != mat.matrizvars.second.second.end(); ++itdim) {
                  s << "[" << *itdim << "]";
                  decl << "[" << *itdim << "]";
                }                
        
                decl << ";";
                addInitStm(decl);
                decl.str("");

                cpy << "matrix_cpy__(" << *itid << "__, " << *itid << ", ";
                switch(mat.matrizvars.first) {
                  case TIPO_INTEIRO:
                    cpy << "'i', ";break;
                  case TIPO_REAL:
                    cpy << "'f', ";break;
                  case TIPO_CARACTERE:
                  case TIPO_LITERAL:
                    cpy << "'c', ";break;      
                  case TIPO_LOGICO:
                    cpy << "'b', ";break;
                }
      
                int tsize = 1;
                for(list<string>::iterator itdim = mat.matrizvars.second.second.begin(); itdim != mat.matrizvars.second.second.end(); ++itdim) {
                  tsize = tsize * atoi((*itdim).c_str());
                }
                cpy << tsize << ");";
                addInitStm(cpy);        
                cpy.str("");
                str << s.str();
                s.str("");
              }
            }
      )*

      //(ret_type)?

      {
        if((_t != antlr::nullAST) && (_t->getType() == TI_FRETURN)) {
          _t = _t->getNextSibling();
        }

        str << ")";
        stringstream prototype;
        prototype << str.str() << ";";
        addPrototype(prototype);

        str << " {";
        writeln(str);
        indent();
      }

      (variaveis[false])?
      stm_block
      {
        //força retorno, se o usuario esqueceu:
//         if(fret != TIPO_NULO) {
//           writeln("return -1;");
//         }

        unindent();
        writeln("}");
        setScope(SymbolTable::GlobalScope);
        _currentScopeType = -1;
      }
    )
  ;*/
  