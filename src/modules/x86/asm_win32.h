_head <<
"%define WINDOWS_CUI\n"
"%define ONLY_NASM\n"
"\n"
"\n"
"\n"
"%define wcall call_\n"
"\n"
"\n"
"%imacro call_ 1-*\n"
"%assign i  %0\n"
" %if %0 > 1\n"
"   %rep %0 - 1\n"
"     %rotate -1\n"
"     %assign i i-1\n"
"     %rotate -1\n"
"     %ifidni %1,\"ADDR_\"\n"
"     %rotate 1\n"
"     lea eax,  [%1]\n"
"     push  eax\n"
"     %rotate -1\n"
"     %assign i i-1\n"
"     %else\n"
"     %rotate 1\n"
"     STDPUSH {%1}\n"
"     %endif\n"
"     %if i <=1\n"
"     %exitrep\n"
"     %endif\n"
"   %endrep\n"
"   %rotate -1\n"
" %endif\n"
" %ifid %1\n"
"   %ifdef %1_definida\n"
"\n"
"     CALL %1\n"
"   %else\n"
"     %ifdef ONLY_NASM\n"
"       CALL [%1]\n"
"     %else\n"
"       extern %1\n"
"       CALL [%1]\n"
"     %endif\n"
"   %endif\n"
" %else\n"
"   CALL %1\n"
" %endif\n"
"%endmacro\n"
"\n"
"\n"
"%macro STDPUSH 1\n"
" %ifnum %1\n"
"\n"
"   %if %1 >= -128 && %1 <= 127\n"
"     push byte %1\n"
"   %else\n"
"     push dword %1\n"
"   %endif\n"
" %else\n"
"   %ifstr %1\n"
"     CONST %%str, db %1, 0\n"
"     push dword %%str\n"
"   %else\n"
"     push dword %1\n"
"   %endif\n"
" %endif\n"
"%endmacro\n"
"\n"
" %imacro CONST 2+\n"
" jmp near %%skip\n"
" %1 %2\n"
" %%skip:\n"
" %endm\n"
"\n"
"\n"
"  BITS 32\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"  %define  _NATIVE       1\n"
"  %define  _WINDOWS_GUI  2\n"
"  %define  _WINDOWS_CUI  3\n"
"  %define  _POSIX_CUI    7\n"
"\n"
"  %define  PAGE    1000h\n"
"  %define  SECTOR    200h\n"
"\n"
"  %define  drvbase   00010000h\n"
"  %define  dllbase   10000000h\n"
"  %define  exebase   00400000h\n"
"\n"
"  %define  HDRSIZE   hdr_end\n"
"\n"
"  %define  CODEPAGES ( ( PAGE + (code_end - code - 1) ) / PAGE )\n"
"  %define  BSSPAGES  ( ( PAGE + (bss_end  - bss  - 1) ) / PAGE )\n"
"\n"
"\n"
"\n"
"  %define     PEFILE\n"
"\n"
"\n"
"\n"
" %ifdef  BSS\n"
"         %define       OBJECTS 2\n"
" %else\n"
"         %define       OBJECTS 1\n"
" %endif\n"
"\n"
"\n"
"\n"
"\n"
"\n"
" %ifdef DRIVER\n"
"    %define    IMAGEBASE   drvbase\n"
"    %define    SECTION     20h\n"
"    %define    FILEAL    SECTION\n"
"    %define    CODE_BASE   HDRSIZE\n"
"    %define    DATA_BASE   __iat_\n"
"    %define    CHARACTERISTICS 10Eh\n"
"    %define    IMGSIZE   end_reloc\n"
"    %define    CODESIZE    (code_end - code)   + (end_init  - init)\n"
"    %define    DATASIZE    (end_iat  - __iat_) + (end_reloc - _reloc)\n"
"    %define    CODEVSIZE   code_raw_end-code\n"
"    %define    STACKRESERVE  40000h\n"
"    %define    SUBSYS    NATIVE\n"
"    %define    OBJECTS     4\n"
"    %define    TSCHARACTERISTICS 068000020h\n"
" %else\n"
"    %ifdef DLL\n"
"     %define  IMAGEBASE        dllbase\n"
"     %define  CHARACTERISTICS    210Eh\n"
"     %define  __DLL\n"
"\n"
"    %else\n"
"     %define  IMAGEBASE      exebase\n"
"     %define  CHARACTERISTICS    103h\n"
"    %endif\n"
"\n"
"\n"
"\n"
"    %ifdef BSS\n"
"   %ifdef DLL\n"
"    %define  BCHARACTERISTICS  0D0000080h\n"
"   %else\n"
"    %define  BCHARACTERISTICS  0C0000080h\n"
"   %endif\n"
"   %define   BSS_SIZE    BSSVSIZE\n"
"    %else\n"
"         %define   BSS_SIZE    0\n"
"    %endif\n"
"\n"
"\n"
"\n"
"        %define    IMGSIZE     _vsize\n"
"    %define    CODE_BASE   PAGE\n"
"    %define    DATA_BASE   CODE_BASE\n"
"    %define    SECTION     PAGE\n"
"    %define    FILEAL    SECTOR\n"
"    %define    CODESIZE    _data_vsize\n"
"    %define    CODEVSIZE   CODEPAGES*1000h\n"
"    %define    BSSVSIZE    BSSPAGES*1000h\n"
"    %define    TSCHARACTERISTICS 0E0000020h\n"
"    %define    DATASIZE    CODESIZE\n"
" %endif\n"
"\n"
"\n"
"\n"
" %ifdef WINDOWS_CUI\n"
"    %define  SUBSYS     _WINDOWS_CUI\n"
" %elifdef NATIVE\n"
"    %define  SUBSYS     _NATIVE\n"
" %else\n"
"    %define  SUBSYS     _WINDOWS_GUI\n"
" %endif\n"
"\n"
"\n"
"\n"
" %define    RVADIFF      CODE_BASE-HDRSIZE\n"
" %define    reloc  RVADIFF+IMAGEBASE\n"
" %define    reloc_bss  (CODE_BASE+CODEVSIZE+IMAGEBASE)-(code_end-code)\n"
"\n"
"\n"
"  Section_setup:\n"
"\n"
" section .head   vstart=IMAGEBASE  start=0\n"
" _head_start:\n"
"\n"
" section .text   vfollows=.head    follows=.head valign=SECTION\n"
" _text_start:\n"
"\n"
" section .data vfollows=.text    follows=.text valign=1  align=1\n"
" _data_start:\n"
"\n"
" section .bss    vfollows=.data    valign=SECTION\n"
" _bss_start:\n"
"\n"
"\n"
"\n"
"\n"
"%macro    rva  1\n"
"     dd  __rva(%1)\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"%define _round(size) (( size + SECTION-1 ) & ~(SECTION-1))\n"
"\n"
"\n"
"%define __rva(label) _head_vsize + label - _text_start\n"
"\n"
"\n"
"\n"
"\n"
"\n"
" %ifdef DRIVER\n"
"   %define ENTRY DriverEntry\n"
" %else\n"
"   %define ENTRY __rva(_start)\n"
" %endif\n"
"\n"
"\n"
"\n"
"\n"
"  header:\n"
"   section .head\n"
"   bits  32\n"
"\n"
"  mz_header:\n"
"\n"
" .magic                    dw  \"MZ\"\n"
" .cblp                     dw  90h\n"
" .cp                       dw  3\n"
" .crlc                     dw  0\n"
" .cparhdr                  dw  4\n"
" .minalloc                 dw  0\n"
" .maxalloc                 dw  -1\n"
" .ss                       dw  0\n"
" .sp                       dw  0B8h\n"
" .csum                     dw  0\n"
" .ip                       dw  0\n"
" .cs                       dw  0\n"
" .lfarlc                   dw  40h\n"
" .ovno                     dw  0\n"
" .res                      times   4 dw 0\n"
" .oemid                    dw  0\n"
" .oeminfo                  dw  0\n"
" .res2                     times   10 dw 0\n"
" .lfanew                   dd  pe_header-IMAGEBASE\n"
"\n"
"  stub:\n"
"\n"
"         CALL  .@W\n"
"         db  \"must on win32!$\"\n"
"       .@W\n"
"         pop dx\n"
"         mov ah, 9\n"
"         int 21h\n"
"\n"
"         mov ah, 4ch\n"
"         int 21h\n"
"\n"
"         align   16, DB 0\n"
"\n"
"  pe_header:\n"
"\n"
" .Signature                dd  \"PE\"\n"
" .Machine                  dw  14Ch\n"
" .NumberOfSections         dw  OBJECTS\n"
" .TimeDateStamp            dd  0\n"
" .PointerToSymbolTable     dd  0\n"
" .NumberOfSymbols          dd  0\n"
" .SizeOfOptionalHeader     dw  0E0h\n"
" .Characteristics          dw  CHARACTERISTICS\n"
"\n"
"  OptionalHeader:\n"
"\n"
" .Magic                    dw  10Bh\n"
" .MajorLinkerVersion       db  0\n"
" .MinorLinkerVersion       db  0\n"
" .SizeOfCode               dd  CODESIZE\n"
" .SizeOfInitializedData    dd  DATASIZE\n"
" .SizeOfUninitialzedData   dd  BSS_SIZE\n"
" .AddressOfEntryPoint      dd  ENTRY\n"
" .BaseOfCode               dd  CODE_BASE\n"
" .BaseOfData               dd  DATA_BASE\n"
" .ImageBase                dd  IMAGEBASE\n"
" .SectionAlignment         dd  SECTION\n"
" .FileAlignment            dd  FILEAL\n"
" .MajorOperSystemVersion   dw  4\n"
" .MinorOperSystemVersion   dw  0\n"
" .MajorImageVersion        dw  0\n"
" .MinorImageVersion        dw  0\n"
" .MajorSubsystemVersion    dw  4\n"
" .MinorSubsystemVersion    dw  0\n"
" .Reserved1                dd  0\n"
" .SizeOfImage              dd  _vsize\n"
" .SizeOfHeaders            dd  _head_size\n"
" .CheckSum                 dd  0\n"
" .Subsystem                dw  SUBSYS\n"
" .DllCharacteristics       dw  0\n"
" .SizeOfStackReserve       dd  100000h\n"
" .SizeOfStackCommit        dd  1000h\n"
" .SizeOfHeapReserve        dd  100000h\n"
" .SizeOfHeapCommit         dd  1000h\n"
" .LoaderFlags              dd  0\n"
" .NumberOfRvaAndSizes      dd  10h\n"
"\n"
"  DataDirectories:\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"   .export     times 2 dd 0\n"
"\n"
"\n"
"\n"
"\n"
" .import     dd  __rva(import), _end_import - import\n"
"\n"
"\n"
"\n"
"\n"
"\n"
" .rsrc     times 2 dd 0\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"   .exception    times 2 dd 0\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"   .certificate    times 2 dd 0\n"
"\n"
"\n"
"\n"
"\n"
"\n"
" .reloc      times 2 dd 0\n"
"\n"
"\n"
"\n"
"\n"
"\n"
" .misc_sectionz    times 10*2 dd 0\n"
"\n"
"\n"
"  SectionTables:\n"
"\n"
"\n"
"%define csize code_end - code\n"
"\n"
"text_section:\n"
" .SectionName              db  \".text\", 0, 0, 0\n"
" .VirtualSize              dd  _data_vsize\n"
" .VirtualAddress           dd  _head_vsize\n"
" .SizeOfRawData            dd  _data_size\n"
" .PointerToRawData         dd  _head_size\n"
" .PointerToRelocations     dd  0\n"
" .PointerToLinenumbers     dd  0\n"
" .NumberOfRelocations      dw  0\n"
" .NumberOfLinenumbers      dw  0\n"
" .Characteristics    dd  TSCHARACTERISTICS\n"
"\n"
"%ifdef BSS\n"
"bss_section:\n"
" .SectionName              db  \".bss\", 0, 0, 0, 0\n"
" .VirtualSize              dd  BSSVSIZE\n"
" .VirtualAddress           dd  CODEVSIZE+PAGE\n"
" .SizeOfRawData            dd  0\n"
" .PointerToRawData         dd  0\n"
" .PointerToRelocations     dd  0\n"
" .PointerToLinenumbers     dd  0\n"
" .NumberOfRelocations      dw  0\n"
" .NumberOfLinenumbers      dw  0\n"
" .Characteristics          dd  BCHARACTERISTICS\n"
"%endif\n"
"\n"
"\n"
"%imacro end 0\n"
"   align FILEAL, db 0\n"
"   section .head\n"
"   align FILEAL, db 0\n"
"_head_size equ $-$$\n"
"_head_vsize  equ _round(_head_size)\n"
"_head_end:\n"
"\n"
"\n"
"   section .text\n"
"   align 4, db 0\n"
"_text_size equ $-$$\n"
"_text_end:\n"
"\n"
"\n"
"   section .data\n"
"_data_size equ $-$$ + _text_size\n"
"_data_end:\n"
"\n"
"\n"
"   section .bss\n"
"   alignb  SECTION\n"
"_bss_vsize equ $-$$\n"
"_bss_end:\n"
"\n"
"\n"
"_data_vsize  equ _round(_text_size + _data_size) + _bss_vsize\n"
"_vsize   equ _head_vsize + _data_vsize\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"%macro library 2\n"
"    dd   0\n"
"           dd   0\n"
"           dd   -1\n"
"    rva  %1\n"
"           rva  %2\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"%define endlibrary times 5 dd 0\n"
"\n"
"\n"
"\n"
"\n"
"%macro  api_import 3\n"
" %1 rva %2\n"
"    %if  %3=1\n"
"   dw   0\n"
"    %endif\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro _MOD 2-4\n"
"  %rep %0/2\n"
"    ModuleNames %1, %2\n"
"    %rotate 2\n"
"  %endrep\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro ModuleNames 2\n"
" %1_i DB %2, 0\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"%macro IAT 0\n"
" raw_code_end:\n"
" align 20h, DB 0\n"
" code_end:\n"
" BEGIN_IMPORT ntoskrnl.exe\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro END_IAT 0\n"
" dd 0\n"
"end_raw_iat:\n"
"align 4, DB 0\n"
"%ifdef _RDATA_\n"
"align 20h, DB 0\n"
"%endif\n"
"end_iat:\n"
"%undef _RDATA_\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"%macro MODULES 0\n"
" %ifnctx module\n"
"  ALIGN 16, DB 0\n"
"  %push module\n"
"  import:\n"
" %endif\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro LIB 2\n"
" %ifnctx lib\n"
"  %assign %$_z 0\n"
"  %push lib\n"
" %endif\n"
" %define fi_%$_z %1\n"
" %define gi_%$_z %2\n"
" %assign %$_z %$_z+1\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro __LIBS_ 2-*\n"
"MODULES\n"
" %rep  %0/2\n"
"   LIB %1, %2\n"
"   %rotate 2\n"
" %endrep\n"
"ENDM\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro ENDM 0\n"
" %ifctx lib\n"
"  %define _LIB_\n"
"  %assign %$_y 0\n"
"  %rep %$_z\n"
"     LIBRARY fi_%$_y\n"
"     %assign %$_y %$_y+1\n"
"  %endrep\n"
"     times 5 DD 0\n"
"     end_import_desc:\n"
"  %assign %$_y 0\n"
"  %rep %$_z\n"
"     _MOD fi_%$_y, gi_%$_y\n"
"     %assign %$_y %$_y+1\n"
"  %endrep\n"
"  %pop\n"
" %else\n"
"\n"
" %endif\n"
" END_MOD\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro LIBRARY 1-2\n"
" %ifdef _LIB_\n"
"   %ifctx lib\n"
"     IMPDESCRIPTOR %1\n"
"     %if %0=2\n"
"       times 5 DD 0\n"
"       end_import_desc:\n"
"     %endif\n"
"   %endif\n"
" %else\n"
"   %ifctx module\n"
"     IMPDESCRIPTOR %1\n"
"     %if %0=2\n"
"       times 5 DD 0\n"
"       end_import_desc:\n"
"     %endif\n"
"   %endif\n"
" %endif\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro LIBRARIES 2-3\n"
" %ifdef _LIB_\n"
" %ifctx lib\n"
"    %rep 2\n"
"     IMPDESCRIPTOR %1\n"
"     %rotate 1\n"
"    %endrep\n"
"    %if %0=3\n"
"     times 5 DD 0\n"
"    %endif\n"
"   %rotate 1\n"
" %endif\n"
" %else\n"
" %ifctx module\n"
"    %rep 2\n"
"     IMPDESCRIPTOR %1\n"
"     %rotate 1\n"
"    %endrep\n"
"    %if %0=3\n"
"     times 5 DD 0\n"
"    %endif\n"
"   %rotate 1\n"
" %endif\n"
" %endif\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro IMPDESCRIPTOR 1\n"
"  %ifdef _DRV_\n"
"   dd   %1_c\n"
"  %else\n"
"   dd   0\n"
"  %endif\n"
"   dd   0\n"
"   dd   0\n"
"   rva  %1_i\n"
"   rva  %1\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro END_MOD 0\n"
" %ifdef _LIB_\n"
"   %undef _LIB_\n"
" %endif\n"
" %ifdef _DRV_\n"
"   ALIGN 4, DB 0\n"
"   end_raw_init:\n"
" %endif\n"
" %ifctx module\n"
"   %pop\n"
" %else\n"
"\n"
" %endif\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"%macro BEGIN_IMPORT 1\n"
" %ifdef _DRV_\n"
"   __iat_:\n"
" %endif\n"
" %push import\n"
"    %1:\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro FUNCTION 3\n"
" %ifnctx fun\n"
"  %assign %$_z 0\n"
"  %push fun\n"
" %endif\n"
" %define ai_%$_z %1\n"
" %define bi_%$_z %2\n"
" %assign ci_%$_z %3\n"
" %assign %$_z %$_z+1\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro ENDI 0\n"
" %ifctx fun\n"
"  %assign %$_y 0\n"
"  %rep %$_z\n"
"   __api_ ai_%$_y\n"
"   %assign %$_y %$_y+1\n"
"  %endrep\n"
"  %assign %$_y 0\n"
"  %rep %$_z\n"
"   _IMPORT ai_%$_y, bi_%$_y, ci_%$_y\n"
"   %assign %$_y %$_y+1\n"
"  %endrep\n"
"  %pop\n"
" %endif\n"
"END_IMPORT\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro  __api_ 1-*\n"
"%ifctx import\n"
"  %rep %0\n"
" %ifdef NORMAL\n"
"   %1_oo: rva %1_k\n"
"   %1 equ %1_oo+reloc\n"
" %else\n"
"         %1: rva %1_k\n"
" %endif\n"
"     %rotate 1\n"
"  %endrep\n"
"%endif\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro iat 3\n"
" %1_k  DW  %3\n"
"   DB  %2, 0\n"
"   ALIGN   2, DB 0\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro hints 1-*\n"
"  %rep %0\n"
"    rva %1_k\n"
"    %rotate 1\n"
"  %endrep\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro __api_ord 2-*\n"
"%ifctx import\n"
"  %rep %0/2\n"
"    %1:  dd %2+80000000h\n"
"    %rotate 2\n"
"  %endrep\n"
"%endif\n"
"%ifndef _ORD_\n"
"  %define _ORD_\n"
"%endif\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro _IMPORT 3-*\n"
"   %ifndef endi\n"
"     DW 0\n"
"     %define endi\n"
"   %endif\n"
"  %rep %0/3\n"
"    iat %1, %2, %3\n"
"    %rotate 3\n"
"  %endrep\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro __IMPORT_ 4-*\n"
"  BEGIN_IMPORT %1\n"
"  %rotate 1\n"
"  %assign %%a %0\n"
"  %assign %%a (%%a-1)/3\n"
"  %rep %%a\n"
" __api_ %1\n"
" %if %0 > 4\n"
"   %rotate 3\n"
" %endif\n"
"  %endrep\n"
"  %if %0 > 4\n"
"   %rotate 1\n"
"  %endif\n"
"  %rep %%a\n"
" _IMPORT %1, %2, %3\n"
" %if %0 > 4\n"
"   %rotate 3\n"
" %endif\n"
"  %endrep\n"
"  END_IMPORT\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%macro END_IMPORT 0\n"
" %ifdef endi\n"
"  %undef endi\n"
" %endif\n"
" %ifdef _ORD_\n"
"   %undef _ORD\n"
"   DD 0\n"
" %endif\n"
" %ifctx import\n"
"  %pop\n"
" %endif\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"%define __BEGIN_IMPORT section .text\n"
"\n"
"%macro __END_IMPORT 0\n"
" _end_import:\n"
" %define import_size _end_import - import\n"
" __SECT__\n"
"%endmacro\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"%macro IMPORT_END 0-*\n"
"_end_import:\n"
"%define  import_size _end_import - import\n"
"end\n"
"%endmacro\n"
"\n"
"%define IMPORT_BEGIN section .text\n"
"\n"
"%define LAST_BEGIN     section .text\n"
"%define LAST_END       IMPORT_END\n"
"\n"
"%macro  begin 1\n"
"    push    ebp \n"
"    mov     ebp,esp\n"
"  %if %1\n"
"    sub     esp,%1\n"
"  %endif\n"
"%endmacro\n"
"\n"
"%macro return 0\n"
"    mov esp, ebp\n"
"    pop ebp  \n"
"    ret\n"
"%endmacro\n"
"\n"
"%macro addarg 1\n"
"    push %1\n"
"%endmacro\n"
"\n"
"%macro clargs 1\n"
"    add esp, 4 * %1\n"
"%endmacro\n"
"\n"
"\n"
"%macro exit 1\n"
"wcall  ExitProcess, %1\n"
"%endmacro\n"
"\n"
"%macro print_lf 0\n"
"  addarg 10\n"
"  call __print_c\n"
"  clargs 1\n"
"%endmacro\n"
"\n"
"%define SIZEOF_DWORD 4\n"
"%define __MEMORY_SIZE  1048576\n"
"%define __BUFFER_SIZE  1024\n"
"\n";



_lib <<
"__imprima_literal:\n"
"    %define string ebp+8\n"
"    begin 0\n"
"\n"
"    mov eax, [string]\n"
"    cmp eax, 0\n"
"    jz .end\n"
"\n"
"    addarg dword [string]\n"
"    call __print\n"
"    clargs 1\n"
"\n"
"\n"
"    .end\n"
"      return\n"
"\n"
"__imprima_inteiro:\n"
"    \n"
"    %define num ebp+8\n"
"\n"
"    \n"
"    %define buffer   ebp-__BUFFER_SIZE\n"
"    begin __BUFFER_SIZE\n"
"    \n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    addarg dword [num]    \n"
"    call __itoa\n"
"    clargs 2\n"
"\n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    call __print\n"
"    clargs 1\n"
"\n"
"    return\n"
"\n"
"__imprima_real:\n"
"    \n"
"    %define num ebp+8\n"
"\n"
"    \n"
"    %define buffer   ebp-__BUFFER_SIZE\n"
"    begin __BUFFER_SIZE\n"
"\n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    addarg dword [num]    \n"
"    call __ftoa\n"
"    clargs 2\n"
"\n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    call __print\n"
"    clargs 1\n"
"\n"
"\n"
"    return\n"
"  \n"
"__print_c:\n"
"    \n"
"    %define carac ebp+8\n"
"\n"
"    begin 0\n"
"\n"
"    lea eax, [carac]\n"
"    addarg eax\n"
"    call __print\n"
"    clargs 1\n"
"\n"
"    return\n"
"\n"
"__imprima_caractere:\n"
"    \n"
"    %define carac ebp+8\n"
"    begin 4\n"
"    \n"
"    addarg dword [carac]\n"
"    call __print_c\n"
"    clargs 1\n"
"\n"
"    \n"
"    return\n"
"\n"
"__imprima_logico:\n"
"    \n"
"    %define val ebp+8\n"
"\n"
"    begin 0\n"
"\n"
"    mov eax, [val]\n"
"    cmp eax, 0\n"
"    jz .false\n"
"    mov eax, __str_true\n"
"    jmp .print\n"
"\n"
"    .false:\n"
"      mov eax, __str_false\n"
"\n"
"    .print:\n"
"      addarg eax\n"
"      call __print\n"
"      clargs 1\n"
"\n"
"  \n"
"    return\n"
"\n"
"__strpos:\n"
"    \n"
"    %define string ebp+12\n"
"    %define carac  ebp+8\n"
"\n"
"    begin 0\n"
"\n"
"    mov eax, [string]\n"
"    cmp eax, 0\n"
"    jnz .calc\n"
"\n"
"    mov eax, 0\n"
"    return\n"
"\n"
"    .calc:\n"
"      mov eax, 0\n"
"      .do:\n"
"        mov ebx, [string]\n"
"        mov ecx, [carac]\n"
"        cmp [ebx+eax], cl\n"
"        jz  .break\n"
"\n"
"        cmp [ebx+eax], byte 0\n"
"        jz .notfound\n"
"\n"
"        inc eax\n"
"        jnz .do\n"
"      .break:\n"
"\n"
"    return\n"
"\n"
"    .notfound\n"
"      mov eax, -1\n"
"      return\n"
"\n"
"__strlen:\n"
"    \n"
"    %define string ebp+8\n"
"\n"
"    begin 0\n"
"\n"
"    addarg dword [string]\n"
"    addarg 0\n"
"    call __strpos\n"
"    clargs 2\n"
"\n"
"    return\n"
"\n"
"__print:\n"
"  %define STD_OUTPUT_HANDLE -11\n"
"  %define string ebp+8\n"
"\n"
"    %define handle  ebp-4\n"
"    %define length  ebp-8    \n"
"    begin 8\n"
" wcall GetStdHandle, STD_OUTPUT_HANDLE\n"
" mov   [handle], eax\n"
"\n"
" addarg dword [string]\n"
"    call __strlen\n"
"    clargs 1\n"
"    mov [length], eax\n"
"\n"
"    wcall WriteConsoleA, [handle], [string], [length], 0, 0\n"
"\n"
"    return\n"
"\n"
"__is_num:\n"
"    \n"
"    %define carac ebp+8\n"
"\n"
"    begin 0\n"
"\n"
"    cmp byte  [carac], 48\n"
"    jl .false\n"
"\n"
"    cmp byte [carac], 57\n"
"    jg .false\n"
"\n"
"    mov eax, 1\n"
"    return\n"
"\n"
"    .false:\n"
"      mov eax, 0\n"
"      return\n"
"\n"
"__atoi:\n"
"    \n"
"    %define string ebp+8\n"
"  \n"
"    \n"
"    %define num   ebp-4\n"
"    %define m     ebp-8\n"
"    %define i     ebp-12\n"
"    %define len   ebp-16\n"
"    %define negt  ebp-20\n"
"    begin 20\n"
"  \n"
"    mov dword [num], 0\n"
"    mov dword [m], 1\n"
"  \n"
"    addarg dword [string]\n"
"    call __strlen\n"
"    clargs 1\n"
"\n"
"    cmp eax, dword 0\n"
"    jz .ret_zero\n"
"\n"
"    mov dword [len], eax\n"
"    mov dword [i], 0\n"
"\n"
"    \n"
"    %define minus_sig 45 \n"
"    %define plus_sig 43\n"
"    mov eax, [string]\n"
"    xor ebx, ebx\n"
"    mov bl, [eax]\n"
"\n"
"    cmp ebx, minus_sig\n"
"    jz .negative\n"
"\n"
"    cmp ebx, plus_sig\n"
"    jz .positive\n"
"\n"
"    jmp .conv\n"
"\n"
"    .negative\n"
"      mov dword [negt], 1\n"
"      mov eax, [string]\n"
"      inc eax\n"
"      mov [string], eax\n"
"      jmp .conv\n"
"\n"
"    .positive\n"
"      mov dword [negt], 0\n"
"      mov eax, [string]\n"
"      inc eax\n"
"      mov [string], eax\n"
"\n"
"  .conv:\n"
"\n"
"    mov eax, [len]\n"
"    .while:\n"
"      mov eax, dword [i]\n"
"      cmp eax, [len]\n"
"      jg .endwhile      \n"
"      \n"
"      mov ebx, [string]\n"
"      mov ecx, [i]        \n"
"      xor edx, edx\n"
"      mov dl, [ebx+ecx]      \n"
"\n"
"      addarg edx\n"
"      call __is_num\n"
"      clargs 1\n"
"  \n"
"      cmp eax, 0\n"
"      jz .endwhile\n"
"  \n"
"      inc dword [i]\n"
"      jmp .while\n"
"    .endwhile:\n"
"  \n"
"    cmp dword [i], 0\n"
"    jz .ret_zero\n"
"  \n"
"\n"
"    dec dword [i]    \n"
"    \n"
"    .while2:\n"
"      cmp dword [i], 0\n"
"      jl .endwhile2\n"
"\n"
"      \n"
"      mov ebx, [string]\n"
"      mov ecx, [i]\n"
"      xor eax, eax\n"
"      mov al, byte [ebx+ecx]\n"
"\n"
"      \n"
"      sub al, 48\n"
"\n"
"      mul dword [m]      \n"
"\n"
"      \n"
"      add [num], eax\n"
"\n"
"      dec dword [i]\n"
"\n"
"      \n"
"      mov eax, [m]\n"
"      mov ebx, 10\n"
"      mul ebx\n"
"      mov [m], eax\n"
"\n"
"      jmp .while2\n"
"    .endwhile2:\n"
"  \n"
"    cmp dword [negt], 1\n"
"    jnz .return_pos\n"
"\n"
"    mov eax, [num]\n"
"    neg eax\n"
"    return\n"
"   \n"
"    .return_pos\n"
"      mov eax, [num]\n"
"      return\n"
"\n"
"    .ret_zero\n"
"      mov eax, 0\n"
"      return\n"
"\n"
"__atof:\n"
"    \n"
"    %define string ebp+8\n"
"\n"
"    \n"
"    %define negt     ebp-4\n"
"    %define dotpos   ebp-8\n"
"    %define declen   ebp-12\n"
"    %define str_dec  ebp-16\n"
"    %define inte     ebp-20\n"
"    %define deci     ebp-24\n"
"    %define p        ebp-28\n"
"    %define float    ebp-32\n"
"    \n"
"    begin 32\n"
"\n"
"    addarg dword [string]\n"
"    call __strlen\n"
"    clargs 1\n"
"\n"
"    cmp eax, dword 0\n"
"    jz .ret_zero\n"
"\n"
"    \n"
"    %define minus_sig 45 \n"
"    %define plus_sig 43\n"
"    mov eax, [string]\n"
"    xor ebx, ebx\n"
"    mov bl, [eax]\n"
"\n"
"    cmp ebx, minus_sig\n"
"    jz .negative\n"
"\n"
"    cmp ebx, plus_sig\n"
"    jz .positive\n"
"\n"
"    jmp .conv\n"
"\n"
"    .negative\n"
"      mov dword [negt], 1\n"
"      mov eax, [string]\n"
"      inc eax\n"
"      mov [string], eax\n"
"      jmp .conv\n"
"\n"
"    .positive\n"
"      mov dword [negt], 0\n"
"      mov eax, [string]\n"
"      inc eax\n"
"      mov [string], eax\n"
"\n"
"  .conv:\n"
"\n"
"    addarg dword [string]\n"
"    addarg '.'\n"
"    call __strpos\n"
"    clargs 2\n"
"    \n"
"    mov dword [dotpos], eax\n"
"\n"
"    \n"
"    mov eax, [string]\n"
"    add eax, [dotpos]\n"
"    inc eax\n"
"\n"
"    mov [str_dec], eax\n"
"\n"
"    addarg dword [str_dec]\n"
"    call __strlen\n"
"    clargs 1\n"
"    \n"
"    mov dword [declen], eax    \n"
"\n"
"    addarg dword [str_dec]\n"
"    call __atoi\n"
"    clargs 1\n"
"\n"
"    mov dword [deci], eax\n"
"\n"
"    mov eax, [string]\n"
"    add eax, [dotpos]\n"
"    mov [eax], byte 0\n"
"\n"
"    addarg dword [string]\n"
"    call __atoi\n"
"    clargs 1\n"
"\n"
"    mov [inte], eax\n"
"\n"
"    mov eax, dword [declen]\n"
"    \n"
"    addarg 10\n"
"    addarg eax\n"
"    call __pow\n"
"    clargs 2\n"
"\n"
"    mov dword [p], eax\n"
"\n"
"    fninit\n"
"    fld   dword [deci]\n"
"    fdiv  dword [p]\n"
"    fiadd  dword [inte]\n"
"    fstp  dword [float]\n"
"\n"
"    cmp dword [negt], 1\n"
"    jnz .return_pos\n"
"\n"
"    mov eax, [float]\n"
"    or eax, 0x80000000\n"
"    return\n"
"   \n"
"    .return_pos\n"
"      mov eax, [float]\n"
"      return\n"
"\n"
"    .ret_zero\n"
"      mov eax, 0\n"
"      return\n"
"\n"
"    exit 0\n"
"\n"
"__itoa:\n"
"    \n"
"    %define buffer ebp+12\n"
"    %define num ebp+8\n"
"\n"
"    \n"
"    %define sig ebp-4\n"
"    begin 4\n"
"\n"
"    \n"
"    mov eax, [num]\n"
"    mov [sig], eax\n"
"    shr eax, 31\n"
"    mov [sig], eax    \n"
"\n"
"    cmp [sig], dword 0\n"
"    jz .endif\n"
"      neg dword [num]\n"
"    .endif:\n"
"\n"
"    \n"
"    mov ecx, 0\n"
"    mov eax, [num] \n"
"    .trans\n"
"      mov ebx, 10\n"
"      mov edx, 0\n"
"      idiv ebx   \n"
"      add edx, byte 48\n"
"      push edx\n"
"      inc ecx \n"
"    cmp eax, 0\n"
"    jnz .trans\n"
"\n"
"    \n"
"    cmp [sig], dword 0\n"
"    jz .else1\n"
"      %define minus_sig 45\n"
"      mov edx, 1 \n"
"      mov eax, [buffer]\n"
"      mov [eax], byte minus_sig            \n"
"      jmp .endif1\n"
"    .else1:\n"
"      mov edx, 0 \n"
"    .endif1\n"
"    \n"
"    .reorder\n"
"      pop eax\n"
"      mov ebx, [buffer]\n"
"      mov [ebx+edx], eax \n"
"      dec ecx \n"
"      inc edx \n"
"    cmp ecx, 0 \n"
"    jnz .reorder\n"
"\n"
"    return\n"
"\n"
"__ftoa:\n"
"    %define BIAS 127\n"
"\n"
"    \n"
"    %define buffer ebp+12\n"
"    %define num ebp+8\n"
"\n"
"    \n"
"    %define exp    ebp-4\n"
"    %define mant   ebp-8\n"
"    %define left   ebp-12\n"
"    %define sig    ebp-16    \n"
"    %define offset ebp-20\n"
"    %define r      ebp-24\n"
"    %define term   ebp-28\n"
"    %define acc    ebp-32\n"
"    %define tmp    ebp-36\n"
"    %define right  ebp-40\n"
"    \n"
"    %define lst    40    \n"
"  \n"
"    begin lst\n"
"\n"
"    \n"
"    mov eax, [num]\n"
"    mov [sig], eax\n"
"    shr eax, 31\n"
"    mov [sig], eax\n"
"\n"
"    \n"
"    mov eax, [num]\n"
"    and eax, 0x7FFFFFFF\n"
"    mov [num], eax\n"
"\n"
"    \n"
"    mov eax, [num]\n"
"    shr eax, 23\n"
"    mov [exp], eax\n"
"\n"
"    \n"
"    mov eax, [num]\n"
"    and eax, 0x7FFFFF\n"
"    mov [mant], eax\n"
"\n"
"    \n"
"    mov eax, [exp]      \n"
"    mov ebx, [mant]\n"
"    or eax, ebx\n"
"      cmp eax, 0\n"
"      jnz .endif\n"
"      mov dword [tmp], 0x00302E30\n"
"      lea eax, [tmp]\n"
"      mov dword [eax+3], 0x00000030\n"
"      addarg eax\n"
"      addarg dword [buffer]\n"
"      call __strcpy\n"
"      clargs 2 \n"
"      jmp .end\n"
"    .endif:\n"
"\n"
"    \n"
"    sub [exp], dword BIAS\n"
"  \n"
"    \n"
"    or [mant], dword 0x800000\n"
"\n"
"    \n"
"    \n"
"    \n"
"    \n"
"    \n"
"    mov eax, 25\n"
"    sub eax, [exp]\n"
"      cmp eax, 32\n"
"      jg .else1   \n"
"      mov eax, [mant]\n"
"      mov ecx, 23\n"
"      sub ecx, [exp]\n"
"      shr eax, cl\n"
"      mov [left], eax\n"
"      jmp .endif1\n"
"    .else1:\n"
"      mov [left], dword 0\n"
"    .endif1:\n"
"\n"
"    \n"
"    \n"
"    \n"
"    \n"
"    \n"
"    \n"
"    mov eax, 9\n"
"    add eax, [exp]\n"
"      cmp eax, 0\n"
"      jl .else2\n"
"      mov ecx, 9\n"
"      add ecx, [exp]\n"
"      mov eax, [mant]\n"
"      shl eax, cl\n"
"      mov [mant], eax\n"
"      jmp .endif2\n"
"    .else2:\n"
"      mov ecx, [exp]\n"
"      sub ecx, 9\n"
"      mov eax, [mant]\n"
"      shr eax, cl          \n"
"    .endif2:\n"
"\n"
"\n"
"    \n"
"    mov [offset], dword 31\n"
"\n"
"    \n"
"    mov eax, [mant]\n"
"    mov [r], eax\n"
"\n"
"    \n"
"    mov [term], dword 1\n"
"\n"
"    \n"
"    mov [acc], dword 0\n"
"\n"
"\n"
"    fninit\n"
"\n"
"    \n"
"    .while:    \n"
"      mov eax, [offset]\n"
"      cmp eax, 1\n"
"      jz .endwhile\n"
"  \n"
"      \n"
"      mov eax, [r]\n"
"      mov ecx, [offset]\n"
"      shr eax, cl\n"
"      and eax, 1\n"
"        cmp eax, 0\n"
"        jz .endif3\n"
"  \n"
"        \n"
"        mov eax, 2\n"
"        mov ebx, [term]\n"
"        neg ebx\n"
"\n"
"        addarg eax\n"
"        addarg ebx\n"
"        call __pow \n"
"        clargs 2\n"
"\n"
"        mov [tmp], eax\n"
"  \n"
"        fld  dword [acc] \n"
"        fadd dword [tmp]\n"
"        fstp dword [acc]\n"
"      .endif3:\n"
"\n"
"      \n"
"      inc dword [term]\n"
"\n"
"      \n"
"      dec dword [offset]\n"
"      jmp .while\n"
"    .endwhile:\n"
"\n"
"    fninit\n"
"\n"
"    \n"
"    fld dword [acc] \n"
"    mov [tmp], dword 100\n"
"    fimul dword [tmp]\n"
"    \n"
"    frndint\n"
"    \n"
"    fist dword [acc]\n"
"\n"
"    mov eax, [acc]\n"
"    mov [right], eax\n"
"\n"
"\n"
"    \n"
"\n"
"    cmp [sig], dword 0\n"
"    jz .endif5\n"
"      neg dword [left]\n"
"    .endif5:\n"
"\n"
"    addarg dword [buffer]\n"
"    addarg dword [left]\n"
"    call __itoa\n"
"    clargs 2\n"
"    \n"
"    \n"
"    addarg dword [buffer]\n"
"    call __strlen\n"
"    clargs 1\n"
"\n"
"    add eax, dword [buffer]\n"
"    mov [eax], byte '.'\n"
"    inc eax\n"
"    mov [tmp], eax    \n"
"\n"
"    \n"
"    %define buffer2 ebp-lst+4\n"
"    %define bfsize  1024\n"
"    sub  esp, bfsize\n"
"\n"
"    addarg dword [buffer2]\n"
"    addarg dword [right]\n"
"    call __itoa\n"
"    clargs 2\n"
"    \n"
"\n"
"    addarg dword [buffer2]\n"
"    call __strlen\n"
"    clargs 1\n"
"\n"
"    \n"
"    cmp eax, 2\n"
"    jz .endif4\n"
"      %define zero 48\n"
"      xor eax, eax\n"
"      mov ebx, [buffer2]\n"
"      mov al, [ebx]\n"
"      mov [ebx], byte zero\n"
"      mov byte [ebx+1], al\n"
"    .endif4:\n"
"\n"
"    mov eax, [buffer2]\n"
"    mov ebx, [tmp]\n"
"    .append:\n"
"      cmp [eax], byte 0\n"
"      jz .endappend\n"
"      \n"
"      xor ecx, ecx\n"
"      mov cl, [eax]\n"
"      mov [ebx], cl\n"
"      inc eax\n"
"      inc ebx\n"
"      jmp .append\n"
"    .endappend:\n"
"\n"
"    mov [ebx], byte 0\n"
"\n"
"  .end\n"
"    return\n"
"\n"
"__pow:\n"
"    \n"
"    %define base ebp+12\n"
"    %define exp  ebp+8\n"
"\n"
"    \n"
"    %define res  ebp-4\n"
"    %define i    ebp-8\n"
"    %define sig  ebp-12\n"
"    %define tmp  ebp-16\n"
"    begin 14\n"
"\n"
"    \n"
"    mov eax, [exp]\n"
"    mov ecx, 31\n"
"    shr eax, cl\n"
"    mov [sig], eax\n"
"\n"
"\n"
"    \n"
"    mov eax, [sig]\n"
"    cmp eax, 0\n"
"    jz .endif\n"
"      mov eax, [exp]\n"
"      neg eax\n"
"      mov [exp], eax\n"
"    .endif:\n"
"\n"
"    \n"
"    mov [res], dword 1\n"
"\n"
"    \n"
"    mov [i], dword 0\n"
"    .while:\n"
"      mov eax, [i]\n"
"      cmp eax, [exp]\n"
"      jge .endwhile\n"
"\n"
"      \n"
"      mov eax, [res]\n"
"      mul dword [base]\n"
"      mov [res], eax\n"
"\n"
"      \n"
"      inc dword [i]\n"
"      jmp .while\n"
"    .endwhile:\n"
"\n"
"    \n"
"    cmp [sig], dword 0\n"
"    jz .noneg\n"
"    .negative:\n"
"      fninit\n"
"      mov [tmp], dword 0x3F800000 \n"
"  \n"
"      fld   dword [tmp]\n"
"      fidiv dword [res]\n"
"      fstp  dword [res]\n"
"    .noneg:\n"
"\n"
"    mov eax, [res]\n"
"\n"
"    return\n"
"\n"
"matrix_init__:\n"
"    \n"
"    %define matrix      ebp+12\n"
"    %define msize       ebp+8\n"
"\n"
"    begin 0\n"
"  \n"
"    mov eax, 0\n"
"    .while:\n"
"      cmp eax, [msize]\n"
"      jge .endwhile\n"
"      mov ecx, [matrix]\n"
"      add ecx, eax\n"
"      mov [ecx], byte 0\n"
"      inc eax\n"
"      jmp .while\n"
"    .endwhile:\n"
"\n"
"    return\n"
"\n"
"__matrix_cpy:\n"
"    %define src       ebp+20\n"
"    %define dest      ebp+16\n"
"    %define is_string ebp+12\n"
"    %define msize     ebp+8\n"
"    begin 0\n"
"\n"
"    mov eax, 0\n"
"    .while:\n"
"      cmp eax, [msize]\n"
"      jge .endwhile\n"
"\n"
"      mov ebx, [src]\n"
"      add ebx, eax\n"
"      xor ecx, ecx\n"
"      mov cl, [ebx]\n"
"\n"
"      mov ebx, [dest]\n"
"      add ebx, eax\n"
"\n"
"      mov [ebx], cl\n"
"\n"
"      inc eax\n"
"      jmp .while\n"
"    .endwhile:\n"
"\n"
"    return\n"
"\n"
"__strcpy:\n"
"    \n"
"    %define src    ebp+12\n"
"    %define dest   ebp+8\n"
"\n"
"    \n"
"    %define src_len     ebp-4\n"
"    begin 4\n"
"\n"
"    addarg dword [src]\n"
"    call __strlen\n"
"    clargs 1\n"
"\n"
"    mov [src_len], eax\n"
"\n"
"    cmp eax, [src_len]\n"
"    jnz .end\n"
"    \n"
"    mov eax, 0\n"
"    mov edx, [dest]\n"
"    .while:\n"
"      cmp eax, [src_len]\n"
"      jge .endwhile\n"
"\n"
"      mov ebx, [src]\n"
"      xor ecx, ecx\n"
"      mov cl, [ebx+eax]\n"
"\n"
"      mov [edx+eax], cl\n"
"\n"
"      inc eax\n"
"      jmp .while\n"
"    .endwhile:\n"
"\n"
"    mov [edx+eax], byte 0\n"
"\n"
"    .end:\n"
"      return\n"
"\n"
"__strcmp:\n"
"    \n"
"    %define left    ebp+12\n"
"    %define right   ebp+8\n"
"\n"
"    \n"
"    %define left_len     ebp-4\n"
"    %define l            ebp-8\n"
"    %define r            ebp-12\n"
"    begin 12\n"
"\n"
"    addarg dword [left]\n"
"    call __strlen\n"
"    clargs 1\n"
"\n"
"    mov [left_len], eax\n"
"\n"
"    addarg dword [right]\n"
"    call __strlen\n"
"    clargs 1\n"
"\n"
"    cmp eax, [left_len]\n"
"    jnz .false\n"
"\n"
"    mov eax, 0\n"
"    .while:\n"
"      cmp eax, [left_len]\n"
"      jge .endwhile\n"
"\n"
"      mov ebx, [left]\n"
"      xor edx, edx\n"
"      mov dl, [ebx+eax]\n"
"\n"
"      mov ebx, [right]\n"
"      xor ecx, ecx\n"
"      mov cl, [ebx+eax]\n"
"      \n"
"      cmp edx, ecx\n"
"      jnz .false\n"
"\n"
"      inc eax\n"
"      jmp .while\n"
"    .endwhile:\n"
"\n"
"    mov eax, 1\n"
"    return\n"
"\n"
"  .false\n"
"    mov eax, 0 \n"
"    return\n"
"\n"
"__malloc:\n"
"    \n"
"    %define size   ebp+8\n"
"\n"
"    begin 0\n"
"\n"
"    cmp [size], dword 0\n"
"    jnz .alloc\n"
"\n"
"    mov eax, 0\n"
"    return\n"
"\n"
"    .alloc:\n"
"      mov eax, __mem        \n"
"      add eax, [__mem_ptr]  \n"
"      add eax, [size]       \n"
"  \n"
"      mov ebx,  __mem      \n"
"      add ebx, __MEMORY_SIZE \n"
"\n"
"      cmp eax, ebx\n"
"      jg .no_memory_left\n"
"\n"
"      \n"
"      mov eax, __mem\n"
"      add eax, [__mem_ptr]\n"
"  \n"
"      \n"
"      mov ebx, [__mem_ptr]\n"
"      add ebx, [size]\n"
"      mov [__mem_ptr], ebx\n"
"\n"
"      return\n"
"    \n"
"   .no_memory_left:\n"
"      addarg __str_no_mem_left\n"
"      call __imprima_literal\n"
"      clargs 1\n"
"      exit 1\n"
"\n"
"__leia_caractere:\n"
"    %define buffer   ebp-__BUFFER_SIZE\n"
"    begin __BUFFER_SIZE\n"
"    \n"
"    \n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    addarg __BUFFER_SIZE\n"
"    call __readline\n"
"    clargs 2\n"
"    \n"
"    lea ebx, [buffer]\n"
"    xor eax, eax\n"
"    mov al, [ebx]\n"
"\n"
"    return\n"
"\n"
"__leia_real:\n"
"    %define buffer   ebp-__BUFFER_SIZE    \n"
"    begin __BUFFER_SIZE\n"
"    \n"
"    \n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    addarg __BUFFER_SIZE\n"
"    call __readline\n"
"    clargs 2\n"
"    \n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    call __atof\n"
"    clargs 1\n"
"\n"
"    return\n"
"\n"
"__leia_inteiro:\n"
"    %define buffer   ebp-__BUFFER_SIZE\n"
"    begin __BUFFER_SIZE\n"
"    \n"
"    \n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    addarg __BUFFER_SIZE\n"
"    call __readline\n"
"    clargs 2\n"
"    \n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    call __atoi\n"
"    clargs 1\n"
"\n"
"    return\n"
"\n"
"__leia_logico:\n"
"    %define zero_str ebp-4\n"
"    %define buffer   ebp-4-__BUFFER_SIZE\n"
"    begin (4+__BUFFER_SIZE)\n"
"    \n"
"    mov [zero_str], dword 0x00000030 \n"
"\n"
"    \n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    addarg __BUFFER_SIZE\n"
"    call __readline\n"
"    clargs 2\n"
"\n"
"    \n"
"    lea eax, [buffer]\n"
"    addarg eax\n"
"    addarg __str_false\n"
"    call __strcmp\n"
"    clargs 2\n"
"\n"
"    cmp eax, 1\n"
"    jz .false\n"
"\n"
"    \n"
"    lea eax, [zero_str]\n"
"    lea ebx, [buffer]\n"
"    addarg eax\n"
"    addarg ebx\n"
"    call __strcmp\n"
"    clargs 2\n"
"\n"
"    cmp eax, 1\n"
"    jz .false\n"
"\n"
"    mov eax, 1\n"
"    return\n"
"\n"
"    .false:\n"
"      mov eax, 0\n"
"      return\n"
"\n"
"__leia_literal:\n"
"    %define string ebp-4\n"
"    begin 4\n"
"\n"
"    addarg __BUFFER_SIZE\n"
"    call __malloc\n"
"    clargs 1\n"
"\n"
"    mov [string], eax\n"
"\n"
"    addarg dword [string]\n"
"    addarg __BUFFER_SIZE\n"
"    call __readline\n"
"    clargs 2\n"
"\n"
"    mov eax, [string]\n"
"    return\n"
"\n"
"__readline:\n"
"    %define STD_INPUT_HANDLE -10\n"
" \n"
"    %define buffer   ebp+12\n"
"    %define size     ebp+8\n"
"\n"
"    %define handle ebp-4\n"
"    %define read ebp-8\n"
"    begin 4\n"
"\n"
"    wcall GetStdHandle, STD_INPUT_HANDLE\n"
"    mov [handle], eax    \n"
"\n"
"    lea eax, [handle]\n"
"    lea ebx, [buffer]\n"
"    lea ecx, [size]\n"
"    lea edx, [read]\n"
"    \n"
"\n"
"    wcall ReadConsoleA, [eax], [ebx], [ecx], edx, 0\n"
"\n"
"    return\n"
"\n"
"__clone_literal:\n"
"  %define string ebp+8\n"
"\n"
"  %define lit ebp-4\n"
"  begin 4\n"
"\n"
"  addarg dword [string]\n"
"  call __strlen\n"
"  clargs 1\n"
"\n"
"  inc eax\n"
"  \n"
"  addarg eax\n"
"  call __malloc\n"
"  clargs 1\n"
"\n"
"  mov [lit], eax\n"
"\n"
"  addarg dword [string]\n"
"  addarg dword [lit]\n"
"  call __strcpy\n"
"  clargs 2\n"
"  \n"
"  mov eax, [lit]\n"
"  return\n\n"
"LAST_BEGIN\n"
"\n"
"__LIBS_         kernel32,  \"kernel32.dll\"\n"
"\n"
"__IMPORT_       kernel32, \\\n"
"       GetStdHandle, \"GetStdHandle\",0, \\\n"
"       WriteConsoleA, \"WriteConsoleA\", 0, \\\n"
"       ExitProcess, \"ExitProcess\", 0, \\\n"
"       ReadConsoleA , \"ReadConsoleA\",0\n"
"       \n"
"LAST_END\n";