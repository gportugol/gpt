\NewEntry 0 devel

\CurrentEntry 1 TODO
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><li>parser.g error handling</li>
<ul type="disc"><li>terminar tratamento nas declaracoes de funcoes</li>
<li>substituir getTokenNames()[DFASDF] por getTokenDescriptioN(TOKEN)</li>
<ul type="disc"><li>overload getTokenDescripion(int)</li></ul>
<li>Verificar todos os consumeUntil() nas excessoes</li>
<li>Limpar comentarios, codigo...<br /></li></ul>
<li>gpt.cpp</li>
<ul type="disc"><li>remover tempnam() e usar mkstemp()</li>
<li>Adicionar opcoes para interpretação, geracao de codigo C (sem compilacao)<br /></li></ul>
<li>pt2c:</li>
<ul type="disc"><li>free(lit)! em leia_literal()<br /><br /></li></ul>
<li>Interpreter:</li>
<ul type="disc"><li>Matrizes e stm_ret</li>
<li>casting na atribuicao ((int)x nao pode ter 2.3 como valor)</li>
<li>Socket conn + step(into|over|out) + continue + breakpoint + watch<br /></li></ul>
<li>Limpar codigos, comentarios.</li>
<ul type="disc"><li>pt2c fix:</li>
<ul type="disc"><li>/home/jester/projects/upis/trunk/pparser/gramaticas/pt2c.g:776:11: warning:Rule 'tipo_prim' returns a value</li>
<li>dar uma olhada nas producoes de ret_type (funcao)<br /></li></ul></ul>
<li>Editor + parser (online analysis check)</li>
<ul type="disc"><li>Plugin não é bom:</li>
<ul type="disc"><li>Funciona com outros tipos de arquivos</li>
<li>Não tem widget mostrando as mensagens de erro</li></ul>
<li>Protoeditor</li>
<ul type="disc"><li>Aproveita infraestrutura, add/removemarks, breakpoints, abstract variables, watches, error msgs, etc</li>
<li>Fork()</li>
<ul type="disc"><li>Fazer de um jeito em que evite replicação.</li>
<li>Não ter settings relacionados a PHP.<br /></li></ul></ul></ul>
<li>Interpreter/Debugger</li>
<li>Adicionar mimetype com icone (x-pseudo-codigo)<br /></li>
<li>Release</li>
<ul type="disc"><li>Site (html manual (wiki), comentarios de implementacao, exemplos, etc)</li>
<li>configure.in configurations (check for antlr)</li>
<li>README, TODO, NEWS<br /><br /></li></ul>
<li>Parser Plugin:</li>
<ul type="disc"><li>Action (enable/disable) pelo menu/shortcut</li>
<li>Linkar com gpt</li></ul>
<div><br />----------------------------------------------------------------------------------------------------------------<br />Checar divisão por 0<br /></div>
<li>Highlight: numeros binarios e octais</li>
<li>Highlight: funcoes()<br /><br />Checar se eh possivel: &quot;imprima()&quot; sem argumentos<br /></li>
<li>Bugs:</li>
<ul type="disc"><li>algoritmo inútil;<br />Linha: 1 - Variável/função &quot;inútil&quot; não pode ter caracteres especiais..<br />-&gt; &quot;inútil&quot; não é nem variável, nem, função. é o nome do algoritmo<br /></li></ul>
<li>Verificação de igualdade de strings! Como está sendo traduzido?deveria ser strcmpi()<br /></li>
<div><br />------------------------------------------------------------------------------------<br /></div>
<li>-Fazer verificação de uso de variaveis?</li>
<ul type="disc"><li>&quot;Aviso: variavel &quot;w&quot; nao esta sendo usada&quot;</li>
<div><br /><br /></div></ul>
<li>-faça/enquanto();</li>
<li>-switch (escolha)<br /></li>
<li>Fazer representacao de numeros binarios? (0 para oct, 0x para hex, 0b para bin?)?<br /><br /><br /></li>
<li>-------------------------------------------------------------------------------------------------------------------<br /><br />Limpeza de codigo:<br /><br />lexer e parser: apenas polir.<br /><br />Semantic, pt2c, interpreter:</li>
<ul type="disc"><li>Remodelar (codigo atual está muito experimental, therefore, mal feito)<br /></li></ul></ul>
</body></html>


\NewEntry 1 traducao para C
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><li>Notas</li>
<ul type="disc"><li>Passagens de parametros de qualquer tipo eh feito por valor.<br /></li></ul>
<li>Casting:</li>
<ul type="disc"><li>(literal)xx := 123; //valido (implicit cast)?</li>
<ul type="disc"><li>Isso pode ser interessante no futuro mas:</li>
<ul type="disc"><li>1: Complica muito mais a tradução para C.</li>
<li>2: Nao sobra muita opcao para ensinar que tipos diferentes devem ser respeitados. </li>
<ul type="disc"><li>E isso eh interessante pois em linguagens compiladas (tipadas), isso eh regra.</li></ul></ul></ul></ul></ul>
<p></p>
<ul type="disc"><li>Semantic:</li>
<li>Checar se as funcoes que retornam dados tem seus respectivos comandos &quot;retorne&quot;.</li>
<ul type="disc"><ul type="disc"><li>Complicado implementar (precisa-se avaliar se os &quot;retorne&quot; estão dentro de &quot;if&quot;s e se serão executados com certeza.)</li></ul></ul></ul>
</body></html>

\NewEntry 2 comentarios
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><li>matrizes podem receber valores que são outras matrizes de mesma dimensao/tipo.</li>
<li>ex: a ,x : matriz[2] de inteiros; a := x; //OK</li>
<ul type="disc"><li>ex2: a : matriz[2] de inteiros; a := func(); //retorna matriz[2] de inteiros. OK<br /><br /><br />Eh possivel, ate de certa forma, interessante implementar isso. Penso que os C arrays devem ser criados dinamicamente. Para isso, seria mais facil criar uma funcao que crie essa matriz (new_matriz()?), informando dimensoes, tamanhos, tipos, etc.. </li>
<ul type="disc"><li>No que se refere a programação, soa como um feature interessante. No entanto, nao creio que teria um bom valor para ensino. Seria mais interessante ter o aluno aprendendo a copiar e manipular as matrizes diretamente por meio das estruturas de controle (se/enquanto...).</li>
<li><br /></li></ul></ul></ul>
</body></html>

\NewEntry 1 notes
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<p></p>
<p>   </p>
<ul type="disc"><li>A analise semantica (contextual parsing) não decora a AST, ja que a semelhança entre portugol e C permite uma traducao mais direta. No entanto, para compilar um fonte em portugol para uma linguagem de mais baixo nivel (codigo de maquina), seria nescessario esse esforco. A AST, então, conter informacoes sobre os operandos e tipos de expressões nos nós </li>
<ul type="disc"><li>ex: &quot;1 == 2&quot; ::= #(== boolean (1 2) )</li>
<li>ex; &quot;1 + 3.4&quot;    ::=  #(+ real (1  3.4) )</li></ul>
<li>Eh ainda, possivel descartar a tabela de simbolos, decorando a AST com as informacoes de identificadores.</li></ul>
</body></html>

\NewEntry 1 Tratamento de erros
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<p></p>
<ul type="disc"><li>A dificuldade em deixar as mensagens de erro uniformes, ao tentar elaborar tratamentos de erros mais detalhados e prestativos.<br /></li>
<li>Será que atrapalha mais do que ajuda continuar a analise sintatica apos errors encontrados?</li>
<ul type="disc"><li>Muitos erros seguintes ao primeiro podem acabar atrapalhando mais.</li>
<ul type="disc"><li>Ao catch[], pode-se lancar um custom exception, a ser recuperado em main.c</li>
<li>Fazer disso uma opcao?</li></ul></ul></ul>
</body></html>

\NewEntry 0 manual

\NewEntry 1 Introdução

\NewEntry 2 Sobre
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><div>G-Portugol é um dialeto da linguagem portugol (ou portugês estruturado), muito usada para </div>
<div>descrever algoritmos de forma livre e espontânea, em portugês. Em geral, livros dedicados </div>
<div>ao ensino de algoritmos, lógica e estruturas de dados utilizam alguma forma dessa linguagem. <br /><br />A proposta de G-Portugol é disponibilizar uma implementação para essa linguagem, fornecendo </div>
<div>ferramentas que ofereçam recursos de edição, compilação e execução de programas escritos nessa <br />linguagem, de forma a favorecer estudantes que dão os primeiros passos no aprendizado de <br />desenvolvimento de softwares, bem como de professores que ensinam disciplinas relacionadas <br />a computação.</div></ul>
</body></html>

\NewEntry 2 G-Portugol
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><li>Características Gerais da linguagem<br /><br />A linguagem em si não difere fundamentalmente ou apresenta novidades em relação ao uso popular de portugol. Abaixo podemos ver um sumário estrutural da linguagem.<br /></li>
<ul type="disc"><li>Declaração de variáveis tipadas:</li>
<ul type="disc"><li>Primitivos inteiros, reais, caracteres, literais e lógicos, assim como matrizes N dimensionais desses tipos.</li></ul>
<li>Estruturas de controle:</li>
<ul type="disc"><li>Condicional:</li>
<ul type="disc"><li>se/então/senão</li></ul>
<li>Repetição:</li>
<ul type="disc"><li>enquanto</li>
<li>para (popularmente o &quot;for&quot;)<br /></li></ul></ul>
<li>Subrotinas:</li>
<ul type="disc"><li>Implementadas no modelo de funções, parametrizadas e com tipo de retorno.<br /></li></ul></ul></ul>
<p></p>
<ul type="disc"><div>Essa estrutura é complementada pelas operações:<br /></div>
<ul type="disc"><li>matematicas:</li>
<ul type="disc"><li>soma (+)</li>
<li>subtração (-)</li>
<li>divisão (/)</li>
<li>multiplicação (*)</li>
<li>modulo (%)</li></ul>
<li>lógicas:</li>
<ul type="disc"><li>menor (&lt;)</li>
<li>maior (&gt;)</li>
<li>menor ou igual (&lt;=)</li>
<li>maior ou igual (&gt;=)</li>
<li>OR (ou)</li>
<li>AND  (e)</li>
<li>NOT (não)</li>
<li>bitwise OR (|)</li>
<li>bitwise AND (&amp;)</li>
<li>bitwise NOT (~)  </li></ul>
<li>de igualdade:</li>
<ul type="disc"><li>igual (=)</li>
<li>diferente (&lt;&gt;)</li></ul>
<li>Atribuição (:=)<br /></li></ul>
<div>E, por fim, duas funções internas disponíveis para IO:</div>
<ul type="disc"><li>leia()</li>
<li>escreva()<br /><br /></li></ul>
<li>Objetivo e filosofia<br /><br /></li>
<li>O objetivo final de G-Portugol e suas ferramentas é facilitar o estudo e o ensino de algorítmo e lógica  de programação usando como linguagem principal o português. Para atingir esse objetivo, é necessário atenção em diversos aspectos referentes a diversas disciplinas.<br /><br />Guidelines para as ferramentas:<br />Deve ser de fácil acesso e utilização por um leigo, alem de ter alto grau em termos de interface visual e usabilidade.<br />Deve ser configurável naquilo que diz respeito a diferentes abordagens de ensino e estilo do professor.<br />Ênfase deve ser dada à representação, ilustração e expressão de estruturas lógicas e processos internos de computadores baseados na arquitetura de Von Newmann.<br /><br /><br />Guideline para a linguagem:<br />A linguagem deve ser totalmente em português respeitando acentuações.<br />Deve ter uniformidade e coerência estrutural.<br />Deve ser simples, e evitar complexidades que desviam a atenção do propósito original para a detalhes da linguagem. (Apenas recursos escenciais devem fazer parte do núcleo.)<br />Deve ser configurável naquilo que diz respeito a diferentes abordagens de ensino e estilo do professor.<br /><br />-----------<br /></li>
<li>Deve ser de fácil acesso e utilização por um leigo, alem de ter alto grau em termos de interface visual e usabilidade.<br /><br />As ferramentas devem ter uma instalação e configuração de fácil manuseio. Configurações avançadas devem ser exibidas separadamente. Embora seja interessante que o uso de algumas ferramentas reflitam o comportamento de ferramentas reais de desenvolvimento de software, esse grau de reflexão deve ser balanceado e, quando possível, um modo simples de uso deve ser disponibilizado.<br />	Exemplo: gpt<br />		Embora seja possível usá-lo como outros compiladores, a partir da linha de comando,<br />		alternativas devem estar presentes, como executá-lo a partir de um editor.<br /><br /></li>
<li>Deve ser configurável naquilo que diz respeito a diferentes abordagens de ensino e estilo do professor.<br /><br />Recursos que podem ser opcionais, devem seguir essa regra, de forma a não oferecer mais do que será usado, poluindo o ambiente visual. Procurar a simplicidade.<br /></li>
<li>Ênfase deve ser dada à representação, ilustração e expressão de estruturas lógicas e processos internos de computadores baseados na arquitetura de Von Newmann.<br /><br />Todo o foco deve ser dado ao ensino-aprendizagem da disciplina. Alunos e professores não devem ser perturbados ou surpreendidos por detalhes das ferramentas. Isso demanda que as mesmas sejam altamente intuitivas no modo de uso. Evitar exceções, procurando alto grau de clareza e uniformidade. <br /><br /><br />----------------------------------------------------------<br /><br /></li>
<li>Pode-se fazer um dialeto de portugol por meio de uma tradução direta do pascal, C ou outra linguagem popular. Ou pode-se criar uma linguagem que, embora semelhante com as anteriores, tenha diferenças fundamentais em sua concepção. <br /><br /><br /><br /><br /></li></ul>
</body></html>

\NewEntry 2 O programa gpt
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><div><span style="font-weight:600">gpt </span>é o programa responsável pela criação do código executável, a partir do código fonte escrito em G-Portugol. O modo de uso é semelhante a compiladores tradicionais, mas gpt não é um compilador, mas um tradutor. Seu trabalho consiste em analizar o código-fonte informado a procura de erros e, em caso de ausência desses, traduzir o código para a linguagem C e, finalmente, chamando um compilador para gerar o código executável.</div>
<div><br />Para informações sobre seu uso, leia o manual, digitando o comando</div>
<ul type="disc"><div>$ man gpt</div></ul></ul>
</body></html>

\NewEntry 1 Para programadores (Express)

\NewEntry 2 Ola Mundo
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><div>Mantendo a tradição, vamos criar nosso primeiro programa. O propósito dele será exibir na <br />tela o texto &quot;Olá mundo&quot;. Abra seu editor favoríto e crie um arquivo chamado &quot;ola_mundo.pt&quot; com o seguinte<br />conteúdo:<br /></div>
<div>algoritmo olamundo;<br /><br />/* <br />   Nosso primeiro programa <br />*/<br />início<br />  imprima(&quot;Olá mundo!&quot;);<br />fim<br /><br /><br />Após salvar o arquivo, digite o seguinte na linha de comando:<br /><br />$ gpt ola_mundo.pt	</div>
<div><br />Se tudo der certo (rezo para isso), um novo arquivo aparecerá no diretório atual, chamado &quot;olamundo&quot;. Podemos, agora, executar nosso programa:</div>
<div><br />$ ./olamundo<br />Olá mundo!<br /><br />E ver o texto &quot;Ola mundo!&quot; aparecer na tela. Note que o arquivo executável é batizado de acordo com o nome do algoritmo, e não, de acordo com o arquivo fonte.<br /><br />Como deve assumir, o que estiver dentro de aspas duplas (&quot;) é tratado como uma string ou constante literal. Escapes são permitidos como EOL (\n), tabulação (\t) dentre outros. Não é permitido a concatenação em multiplas linhas como em C:<br /><br />	imprima(&quot;Isso é uma &quot;<br />	               &quot;Concatenação&quot;); //erro!<br /><br />Comentários ao estilo C (/**/) e C++ (//) são permitidos.<br /><br />Outro detalhe é a pontuação. Da mesma forma que em C, o &quot;;&quot; é utilizado como finalizador de comandos, muito embora algumas semelhanças com o pascal tenham sido mantidas (como a declaração de variáveis e definição de blocos).<br /></div></ul>
</body></html>

\NewEntry 2 Variáveis e estruturas condicionais
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><li>Variáveis primitivas<br /></li>
<div>A declaração de variáveis deve ser feita dentro de um bloco específico, que deve aparecer logo após a declaração do algorítmo. O bloco é iniciado pela palavra chave &quot;variáveis&quot; (sim, com acento) e termina com a palavra chave &quot;fim-variáveis&quot;. Pelo menos uma variável deve ser declarada dentro do bloco (embora o bloco seja opicional), e apenas um bloco deve ser declarado.<br /><br />Para declarar uma variável &quot;x&quot; do tipo inteiro, e uma variável &quot;nome&quot; do tipo literal, escrevemos assim:<br /><br />algoritmo inútil;<br /><br />variáveis<br />  x : inteiro;<br />  nome : literal<br />fim-variáveis<br /><br />início<br />fim<br /><br />Cinco pontos devem ser evidenciados no exemplo acima. <br /><br />O primeiro é o nome do algoritmo: ele tem acento. Se tentar compilar esse código, um erro saltará da tela.<br /><br />Linha: 1 - &quot;inútil&quot; não pode ter caracteres especiais..</div>
<div><br />Identificadores (nomes de variáveis, funções e do algoritmo) não podem ter acentos ou caracteres especiais (leu a mensagem de erro?). A definição de um identificador em G-Portugol é equivalente ao das linguagens populares: uma letra (a-z ou A-Z) seguido de qualquer número ou letras. Cedilhas estão fora, é claro.<br /><br />O segundo ponto, é a palavra-chave &quot;variáveis&quot;: ela tem acento. Veja o capitulo sobre a implementação para maiores detalhes sobre esse assunto.<br /><br />O terceiro, é a definição do bloco e sua (falta de) semelhança com o Pascal. Todas os blocos em G-Portugol seguem o formato &quot;nome/fim-nome&quot;, em favor da uniformidade e em detrimento de exceções linguísticas que causam dor de cabeça aos estudantes (maiores detalhes, ver implementacao da linguagem).<br /><br />E, finalmente, o quarto ponto é a ausência de código entre &quot;início&quot; e &quot;fim&quot;. O programa não é obrigado a ter enunciados ou comandos. Meros detalhes....<br /><br />Voltando a declaração de variáveis. O formato geral é como se segue:<br />	[identificador] : [tipo];<br /><br />Tal qual Pascal (3 palavras consecutivas terminadas em &quot;al&quot;! Ual!! ).<br /><br />No exemplo, as variáveis &quot;x&quot; e &quot;nome&quot; estão disponível para nosso programa. Tipos inteiros são números inteiros que combrem a faixa de[...] até [...]. Sim, o mesmo que em C (para detalhes de tradução portugol =&gt; C, veja o capitulo sobre a implementação da tradução)<br /><br />Assim que um programa é executado, todas as variáveis declaradas são iniciadas com um valor nulo ou &quot;0&quot;.</div>
<div><br />Para maiores detalhes sobre os tipos de dados suportados, clique aqui.<br /><br />Nota: identificadores constantes não são suportados.<br /></div>
<li>Matrizes<br /><br />Matrizes N dimensionais de tipos primitivos é suportado. Um exemplo de declaração de uma matriz:<br /><br />variáveis<br />   bitset : matriz[10] de lógicos;<br />   quadr : matriz[4][4] de inteiros;<br />fim-variáveis<br /><br />Os subscritos na declaração indicam o tamanho da matriz, e sua dimensão é informada pelo numero de subscritos. É importante observar que matrizes são &quot;0 based&quot;, logo, a matriz &quot;bitset&quot; pode ser usada do indice 0 até o indice 9 (incluindo). Seu indice 10 está fora de cogitação, e seu uso implicará em segmentation faults que irão assombrar seus melhores dias.<br /><br />Matrizes, assim como variáveis de tipos primitivos, são inicializadas com o valor 0/nulo em todas as suas posições.<br /><br />Quando usadas como argumentos de funções, matrizes são passadas &lt;b&gt;por valor&lt;/b&gt;. No entanto, argumentos do tipo matriz não são aceitos pela função &quot;imprima&quot;. Também não são válidas como lvalues<br /><br />	bitset := quadr; //erro! Nem que fosse do mesmo tipo/dimensoes.....<br /></li>
<li>Estruturas condicionais<br /><br />O títilo deveria ser no singular. Por enquanto, apenas a estrutura se/então/senão é suportada. <br /><br />Seguindo o exemplo anterior, eis um algorítmo simples que verifica se o usuário é maior de idade.<br /><br />algoritmo idade;<br /><br />variáveis<br />  idade : inteiro;<br />  nome : literal;<br />fim-variáveis<br /><br />início<br />  imprima(&quot;Digite seu nome:&quot;);<br />  nome := leia();<br />  imprima(nome, &quot;, digite sua idade:&quot;);<br />  idade := leia();<br /><br />  se idade &gt;= 18 então<br />    se nome = &quot;Malkovich&quot; então<br />       imprima(&quot;Malkovich, malkivich malkovich? Malkovich!&quot;);       <br />    senão<br />       imprima(&quot;Bem vindo senhor&quot;, '!');<br />  senão<br />    imprima(&quot;Vai brincar de Home-Aranha em outro lugar...&quot;);<br />  fim-se<br />fim<br /><br />Mais uma vez, vamos passar a lente em alguns pontos.<br /></li>
<ul type="disc"><li>O nome do algoritmo é &quot;idade&quot;, assim como o nome de uma variável. Não há conflitos.<br /></li>
<li>O operador de atribuição é o pascal-like &quot;:=&quot;. (ver detalhes de implementação)<br /><br />A função interna &quot;leia&quot; pode ser usada por variáveis de qualquer tipo primitivo. Para evitar surpresas (numeros inteiros recebendo strings, por exemplo), leia sobre a implementação interna aqui.<br /></li>
<li>A função &quot;imprima&quot; recebe um número de argumentos variáveis, que podem ser constantes literais ou variáveis primitivas. Os valores são concatenados e adicionados de um caractere EOL (end of line, ou fim de linha).<br /></li>
<li>Já vimos que strings/literais constantes são denotados por texto entre aspas duplas (&quot;). Tal qual em C, um caractere entre aspas simples (') é um caractere constante que, da mesma forma, pode permitir escapes como '\n'.<br /></li>
<li>Assim como a palavra-chave &quot;variáveis&quot;, &quot;então&quot; e &quot;senão&quot; devem ser acentuadas.<br /></li>
<li>Como em &quot;variáveis/fim-variáveis&quot;, blocos &quot;se&quot; (não confundir com blocos &quot;C&quot;!) tem seus respectivos e obrigatórios &quot;fim-se&quot;. Não há a exceção de &quot;um enunciado, apenas&quot; encontrado na linguagem C onde o uso de &quot;{}&quot; é opcional . Também, não há imposições sobre a indentação.<br /></li>
<li>A equivalência da expressão &quot;nome = &quot;Malkovich&quot;&quot; é computada como se espera, respeitando os tipos de dados. Salienta-se que comparações de tipos literais são feitas em &lt;br&gt;case sensitive&lt;/b&gt;. Para maiores informações sobre operações sobre literais, clique aqui (&gt;=, &lt;= &lt;&gt;..<br /></li></ul></ul>
</body></html>

\NewEntry 2 Estruturas de repetição
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><li>Enquanto </li>
<li></li>
<li>para/de/até/passo/faça</li></ul>
</body></html>

\NewEntry 2 Operações e constantes
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><li>matematicas/logicas, etc...</li>
<ul type="disc"><li>Tabela de precedencia<br />	</li></ul>
<li>constantes hexadecimais, octais, decimais, (binarias)?</li>
<ul type="disc"><li>hexadecimais iniciam com &quot;0x&quot; ou &quot;0X&quot;</li>
<li>octais iniciam com &quot;0c&quot;</li>
<ul type="disc"><li>Em C: &quot;0&quot;</li>
<ul type="disc"><li>quebra uniformidade</li></ul>
<li>em Prolog: &quot;0o&quot;</li>
<ul type="disc"><li>falta clareza.</li></ul></ul>
<li>binarios iniciam com &quot;0b&quot;<br /></li></ul>
<li>Nota sobre a falta de operações sobre literais/string<br /><br /></li></ul>
</body></html>

\NewEntry 2 Funções

\NewEntry 2 Issues
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:11pt;font-family:Bitstream Vera Sans">
<ul type="disc"><li>Por ser uma traducao....blabla<br />Usando variavel &quot;log : lógico&quot;, por exemplo, gera um gcc warning:<br />	tmp/c__W1ZrBG:145: warning: built-in function `log' declared as non-function<br /><br /></li>
<li>Sobre a funcao leia()</li>
<ul type="disc"><li>restricoes causadas pela implementacao da traducao</li>
<ul type="disc"><li>participacao em expressoes (não eh permitido em expressoes com N termos, ou aplicada a operadores unarios).</li></ul>
<li>No entanto, eh permitido &quot;mat[leia()] := 10&quot;</li></ul></ul>
</body></html>

\NewEntry 1 Implementação

\NewEntry 1 Funções

\NewEntry 1 A linguagem em detalhes

\NewEntry 1 Implementação

