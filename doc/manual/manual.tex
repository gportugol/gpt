% TODO: rever referencias a implementação da gramatica
%       mudar aspas nos codigos verbantim para aspas reais (para que o leitor possa copiar e colar sem ter que mudar
%         o caractere das aspas).              
%       Glossario e padronizacao de termos: uso de vetor e matriz, significando coisas distintas, e o que significam
%       Mudar reticencias "..." pelo comando de reticencias

\documentclass[a4paper,10pt]{report}
\makeatletter

% page setup
\oddsidemargin  0.0in
\evensidemargin 0.0in
\textwidth      6.5in
\headheight     0.2in
\topmargin      0.0in
\textheight=9.0in

\pagestyle{myheadings}     % Go for customized headings
\newcommand{\capitulo}[1]  % Re-define the chaptering command
        { 
          \chapter{#1}

          %http://www.devdaily.com/blog/Content/2/18/408/
          %\lhead{\nouppercase{\rightmark} (\nouppercase{\leftmark})}

          \lhead{Capítulo \thechapter. \nouppercase{\leftmark} }
          \chead{}
          \rhead{}
          \lfoot{G-Portugol}
          \cfoot{}
          \rfoot{\thepage}
          \renewcommand{\headrulewidth}{0.4pt}
          \renewcommand{\footrulewidth}{0.4pt}
          \renewcommand{\sectionmark}[1]{%
            \markboth{#1}{}
          }

          % seta o footer das paginas de capitulo (sem isso, aparece o pagenum centralizado apenas)
          \fancypagestyle{plain}{%
            \fancyhead{} % remoev o header
            \renewcommand{\headrulewidth}{0pt} % e a linha
          }
        }


\usepackage{fancyhdr} %Declares the package fancyhdr
\pagestyle{fancy} %Forces the page to use the fancy template

\fancypagestyle{empty}
\fancyhf{} %Clears all header and footer fields, in preparation.
\fancyhead[EO]{\thepage} %Even and Odd pages: set the \thepage value
\fancyhead[C]{} %clear center text
\fancyhead[LO]{\rightmark} %Displays the lower-level (chapter) information - as


\usepackage[brazilian]{babel} %traduz data, ``capitulo'', etc...
\usepackage[latin1]{inputenc} %permite acentos diretamente
\usepackage[T1]{fontenc} %to get the hyphenation right.
%\usepackage{times}
%\usepackage{aeguill}

% \usepackage{hyperref} %referencias para PDF

\usepackage{float}

\floatstyle{ruled}
\newfloat{program}{thp}{lop}
\floatname{program}{Programa}

\floatstyle{plain}
\newfloat{code}{thp}{lop}
\floatname{code}{Codigo}

\renewcommand{\rmdefault}{phv} %helvetica


% \def\thickhrulefill{\leavevmode \leaders \hrule height 1pt\hfill \kern \z@}
\renewcommand{\maketitle}{

  \begin{titlepage}%

    %% remove footer (sem isso, aparece o numero da pagina)
    \fancyhf{} 
    \fancypagestyle{empty}{%
      \fancyhead{} % remoev o header
      \renewcommand{\headrulewidth}{0pt} % e a linha
    }

    
    \let\footnotesize\small
    \let\footnoterule\relax
    \parindent \z@
    \reset@font
    \null
    \vskip 50\p@
    \begin{center}
      \hrule
      \vskip 1pt
      \hrule
      \vskip 1pt
      {\huge \bfseries \strut \@title \strut}\par
      \vskip 1pt
      \hrule
      \vskip 1pt
      \hrule
      
      \vskip 5pt 
      \Large Manual da versão \@version

    \end{center}
    \vskip 5\p@
    \vfil
    \null

    \vskip 350pt
    \begin{flushright}
    {\Large \@author \par}
    {\Large \@email \par}
    \vskip 100pt
    {\Large \@date\par}    
    \end{flushright}  

  \end{titlepage}%

  \setcounter{footnote}{0}%

}
%\makeatother %nao sei pra que isso serve...

\def\email#1{\def\@email{#1}}
\def\version#1{\def\@version{#1}}

\title{G-Portugol}
\version{v1.0}
\author{Thiago Silva}
\email{\texttt{thiago.silva@kdemail.net}}


\usepackage[pdftex,                %%% hyper-references for pdflatex
    bookmarks=true,%                   %%% generate bookmarks ...
    bookmarksnumbered=true,%           %%% ... with numbers
    hypertexnames=false,%              %%% needed for correct links to figures !!!
    breaklinks=true,%                  %%% break links if exceeding a single line
    colorlinks=true,
    linkcolor=blue,
    pdfborder={0 0 0}]
  {hyperref} %%% blue frames around links


\hypersetup{
 pdfauthor = {\@author},
 pdftitle = {\@title},
 pdfsubject = {Linguagem de programação},
 pdfkeywords = {portugol, programação},
 pdfcreator = {LaTeX with hyperref package},
 pdfproducer = {dvips + ps2pdf}
}

\begin{document}

\maketitle

\tableofcontents

\begin{abstract}
Esse não é um livro que ensina programação, algoritmos ou lógica. Seu objetivo é servir de manual para a linguagem G-Portugol
e ferramentas relacionadas. Portanto, ele assume que o leitor seja versado em linguagens de programação e desenvolvimento de software.

\end{abstract}



\capitulo{Introdução}

G-Portugol é um dialeto da linguagem portugol (ou portugês estruturado), que é muito usada para 
descrever algoritmos em português, de forma livre e espontânea. Em geral, livros dedicados 
ao ensino de algoritmos, lógica e estruturas de dados utilizam alguma forma dessa linguagem. 

A proposta de G-Portugol é disponibilizar uma implementação da linguagem portugol, 
fornecendo ferramentas que ofereçam recursos de edição, compilação, execução e depuração de 
programas escritos nessa linguagem, de forma a favorecer estudantes que dão os primeiros 
passos no aprendizado de desenvolvimento de softwares, bem como professores que ensinam 
disciplinas relacionadas a computação. Portanto, seu foco é primariamente didático.

Se encontram disponíveis atualmente um tradutor/interpretador para a linguagem (GPT) e um ambiente visual simples (GPTEditor)
que permite execução e depuração de programas escritos em G-Portugol. 

A seguir é apresentado os assuntos abordados nos capítulos seguintes:

\begin{itemize}
 \item 
  Capítulo 2: pretende discutir as características gerais da linguagem. 

  \item
  Capítulo 3: aborda a programação em G-Portugol, suas estruturas e recursos, utilizando exemplos ilustrativos e 
  comparando com linguagens populares. Embora o capítulo trate da programação, ele não tem como objetivo explicar 
  programação em si ou a teoria/historia por traz das estruturas abordadas. 

  \item
  Capítulo 4: trata da implementação da linguagem. Discute as decisões de design e recursos oferecidos por G-Portugol.

  \item
  Capítulo 5: descreve o programa GPT, o tradutor/interpretador e depurador para a linguagem G-Portugol.

\end{itemize}

No apêndice deste livro pode ser encontrado a gramática da linguagem G-Portugol.

\capitulo{Características Gerais}

A linguagem em si não difere fundamentalmente ou apresenta novidades em relação ao uso popular de 
portugol. Semelhante à linguagens como Pascal e C, é uma linguagem imperativa, com comandos de 
controle de fluxo, manipulação de dados e recursos de entrada e saída básicos.

\section{Tipos de dados}

Tipos primitivos como inteiro e literal são suportados, assim como matrizes "n" dimensionais de tipos primitivos. 
Além das estruturas de controle, subprogramas são suportados no modelo de funções parametrizadas com retorno
de dados primitivos. Entre os tipos primitivos, se encontram:

\begin{table}[ht]
\begin{center}
  \begin{tabular}{|l|l|}
    \hline
    \multicolumn{2}{|c|}{Tipos primitivos} \\
    \hline
      Tipo & Exemplos \\
    \hline
    inteiro & 19 \\
    real & 2.5 \\
    caractere & 'a' \\
    literal & ``uma frase'' \\
    lógico & verdadeiro \\
    \hline
  \end{tabular}
  \label{tb_tipos_primitivos}
  \caption{Tipos de dados primitivos}
\end{center}
\end{table}

Com esses tipos, pode-se criar conjuntos como vetores ou matrizes ``n'' dimensionais. Tipos mais complexos,
não são suportados, pois o objetivo é ter um conjunto básico o suficiente para o ensino de algorítmos e 
suas estruturas de controle. 

\section{Estruturas de controle}

Da mesma forma, o conjunto de estruturas de controle são os mais primitivos. Uma estrutura condicional 
(se/senão) e duas estruturas de repetição (enquanto/para) são suportadas. Embora a estrutura ``para''
seja uma especialização de um laço simples como o ``enquanto'', ela foi implementada, visto
que tanto uma variedade de livros como professores, discutem seu funcionamento.

\begin{table}[ht]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{2}{|c|}{Estruturas de repetição} \\
      \hline
        Estrutura & Tipo \\
      \hline
      se/então/senão/& condicional \\
      enquanto & repetição \\
      para & repetição \\
      \hline    
    \end{tabular}

    \label{tb_estruturas_de_repeticao}
    \caption{Estruturas de repetição}
  \end{center}
\end{table}


\section{Subprogramas (funções)}

Subprogramas são como funções em C. Podem receber qualquer número de parâmetros, sejam tipos primitivos
ou vetores, e podem retornar valores primitivos. Entretanto, não é permitido declarar funções aninhadas ou
funções com parâmetros variáveis. Vale ressaltar que passagem de parâmetros é sempre feita por 
\textit{valor}.


\capitulo{Programando em G-Portugol}

A proposta desse capítulo é mostrar os elementos da linguagem G-Portugol usando programas como exemplos. Não 
é um capítulo sobre como programar, nem tem como intuito ensinar algorítmos. Portanto, é esperado que o 
leitor seja familiarizado com programação.

\section{Olá Mundo}

Mantendo a tradição, vamos criar nosso primeiro programa. O propósito dele será exibir na tela o 
texto "Olá mundo". Abra seu editor favorito e crie um arquivo  chamado "olamundo.gpt" com o seguinte 
conteúdo:

\begin{program}
  \begin{verbatim}
/* 
  Nosso primeiro programa 
*/
  
algoritmo olamundo;
  
início
  imprima("Olá mundo!");
fim
  \end{verbatim}
  \caption{``Olá Mundo'' em G-Portugol.}
\end{program}

\noindent 
Após salvar o arquivo, digite o seguinte na linha de comando:

\begin{verbatim}
$ gpt -o olamundo olamundo.gpt
\end{verbatim}

Se tudo ocorrer como esperado, um novo arquivo aparecerá no diretório atual, 
chamado "olamundo". Podemos, agora, executar o programa da seguinte forma:

\begin{verbatim}
$ ./olamundo
Olá mundo! 
\end{verbatim}

Então, observe ``Olá mundo!'' aparecer na tela. Note que o arquivo executável é batizado de acordo com o nome 
do algoritmo e não, de acordo com o arquivo fonte.

Como já deve ter assumido, comentários ao estilo C (/**/) e C++ (//) são permitidos e o que estiver entre aspas 
duplas (") é tratado como uma string ou constante literal. 
Escapes são permitidos como EOL ($\backslash$n), tabulação ($\backslash$t) dentre outros. Não é permitido a 
concatenação em multiplas linhas como na linguagem C:

\begin{verbatim}
  imprima("Isso é uma "
          "Concatenação"); //erro!
\end{verbatim}

Outro detalhe é a pontuação. Da mesma forma que em C, o ``;'' é utilizado como finalizador de enunciados.


\section{Variáveis}

A declaração de variáveis deve ser feita dentro de um bloco específico, que deve aparecer logo após a 
declaração do algoritmo. O bloco é iniciado pela palavra-chave ``variáveis'' (sim, com acento) e 
termina com a palavra chave ``fim-variáveis''. Pelo menos uma variável deve ser declarada dentro do bloco 
(embora o bloco em si seja opcional), e apenas um bloco em escopo global deve ser declarado. 
Eis um exemplo para estudo:

\begin{program}  
  \begin{verbatim}  
algoritmo inutil;

variáveis
  x    : inteiro;
  nome : literal
fim-variáveis

início
fim
  \end{verbatim}  
  \caption{Declaração de variáveis globais.}
  \label{programa_inutil}
\end{program}
 

\subsection{Variáveis primitivas}

Variáveis primitivas são declaradas seguindo o seguinte modelo:

\begin{verbatim}
<identificador> [, identificador]* : <tipo>; 
\end{verbatim}

Como pode-se notar, é parecido com Pascal. Assim que um programa é executado, todas as variáveis declaradas são 
iniciadas com um valor nulo ou ``0'' automaticamente. Vale ressaltar que constantes (const, final, etc) não são 
suportados. Os tipos primitivos suportados encontram-se na tabela \ref{tb_tipos_primitivos}

A fim explorar melhor os aspectos da declaração, seguem-se cinco comentários a respeito do último 
exemplo (programa \ref{programa_inutil})

\begin{itemize}
 \item 
  O primeiro é o nome do algoritmo (inutil): ele não tem acento. Se declarar o algoritmo como ``inútil'' 
  e tentar compilar o código, o seguinte erro será exibido:

  \textbf{Linha: 1 - ``inútil'' não pode ter caracteres especiais.}

  Como está claro, identificadores (nomes de variáveis, funções e do algoritmo) não podem ter acentos ou 
  caracteres especiais. A definição de um identificador em G-Portugol é equivalente ao das linguagens 
  populares: uma letra (a-z ou A-Z) seguido de qualquer número de letras ou números (e underscores). 
  Cedilhas, portanto, também não formam identificadores válidos.

 \item 
  O segundo ponto, é a palavra-chave ``variáveis'': ela tem acento, e isso é permitido e de propósito. 
  Veja o capítulo sobre a implementação para maiores detalhes sobre esse assunto.

  \item
  O terceiro, é a definição do bloco e sua (falta de) semelhança com o Pascal. Todas os blocos em G-Portugol 
  tentam seguir o formato ``nome/fim-nome'', em favor da uniformidade e em detrimento de exceções linguísticas 
  que causam dor de cabeça aos estudantes (no entanto, ainda existem excessões. Mais informações no capítulo
  sobre a implementação *todo*.). 


  \item 
  E, finalmente, o quarto ponto é a ausência de código entre ``início'' e ``fim''. 
  O programa não é obrigado a ter enunciados ou comandos. Meros detalhes... 
\end{itemize}


\subsection{Vetores e matrizes}

Vetores e matrizes ``n'' dimensionais de tipos primitivos são suportados. Um exemplo de declaração de uma matriz:

\begin{verbatim}
variáveis
   bitset : matriz[10] de lógicos;
   quadr : matriz[4][4] de inteiros;
fim-variáveis 
\end{verbatim}

O tipo do vetor ou matriz é dado pelo nome do tipo no plural (``inteiros'' para tipo inteiro, ``literais'' 
para tipo literal, etc). Os subscritos na declaração (delimitados por ``[]'') indicam o tamanho da matriz, 
e sua dimensão é informada pelo numero de subscritos. Portanto, ``bitset'' é um vetor de 10 valores lógicos,
enquanto ``quadr'' é uma matriz bidimensional, onde as duas dimensões tem tamanho 4.

É importante observar que matrizes são ``0 based'', logo, a matriz ``bitset'' pode ser usada 
do indice 0 até o indice 9 (inclusive). Seu indice 10 não é válido e seu uso poderá acarretar em erros de execução
(\textit{runtime errors}). Matrizes, assim como variáveis de tipos primitivos, são inicializadas com o 
valor 0 ou nulo em todas as suas posições. Quando usadas como argumentos de funções, matrizes 
são passadas \textit{por valor}.

\begin{program}
  \begin{verbatim}
 variáveis
  m1 : matriz[2] de inteiros;
  m2 : matriz[2] de inteiros;
fim-variáveis

início
  m1 := m2;    //erro
  imprima(m1); //erro
fim
  \end{verbatim}
  
  \caption{Uso incorreto de matrizes.}
\end{program}


\section{Estruturas condicionais}

Por enquanto, apenas a estrutura se/então/senão é suportada. 
Eis um algoritmo simples que verifica se o usuário é maior de idade:

\begin{program}
 \begin{verbatim}
algoritmo idade;

variáveis
  idade : inteiro;
  nome : literal;
fim-variáveis

início
  imprima("Digite seu nome:");
  nome := leia();
  imprima(nome, ", digite sua idade:");
  idade := leia();

  se idade >= 18 então
    se nome = "Malkovich" então
       imprima("Malkovich, malkivich malkovich? Malkovich!");       
    senão
       imprima("Bem vindo senhor ", nome, '!');
  senão
    imprima("Larga o computador, guri!");
  fim-se
fim 
  \end{verbatim}
  %\label{programa_exemplo_condicional}
  \caption{Exemplo de programa que utiliza estrutura condicional.}
\end{program}

Alguns pontos a serem considerados:


\begin{itemize}
  \item 
  O nome do algoritmo é ``idade'', assim como o nome de uma variável. Não há conflitos. 

  \item
  O operador de atribuição é o pascal-like ``:=''. (ver detalhes de implementação *todo*) 

  \item
  A função interna ``leia'' pode ser usada por variáveis de qualquer tipo primitivo. Para evitar surpresas 
  (números inteiros recebendo strings, por exemplo), leia sobre a implementação interna aqui *todo*.

  \item
  A função ``imprima'' recebe um número de argumentos variáveis, que podem ser constantes literais ou variáveis 
  primitivas. Os valores são concatenados e adicionados de um caractere EOL (end of line, ou fim de linha). 

  \item
  Já vimos que strings/literais constantes são denotados por texto entre aspas duplas ("). Tal qual em C, 
  um caractere entre aspas simples (') é um caractere constante que, da mesma forma, pode permitir escapes como 
  '$\backslash$n'. 

  \item
  Assim como a palavra-chave ``variáveis'', ``então'' e ``senão'' devem ser acentuadas. 

  \item
  Como em ``variáveis/fim-variáveis'', blocos ``se'' tem seus respectivos e obrigatórios ``fim-se''. 
  Não há a exceção de "um enunciado, apenas" encontrado na linguagem C onde o uso de ``{}'' é opcional. 
  Também, não há imposições sobre a indentação.

  \item
  A equivalência da expressão ``nome = "Malkovich'' é computada como se espera (comparação caractere por caractere), 
  respeitando os tipos de dados. Salienta-se que comparações de tipos literais são feitas em case sensitive. 
  Para maiores informações sobre operações sobre literais, veja o capitulo *todo*.
\end{itemize} 

\begin{program}
  \begin{verbatim}
//código inválido: faltando fim-se
algoritmo se_invalido;

início
  se x = 2 então
    imprima("ok");
  imprima("estou dentro ou fora do bloco \"se\"?");
fim 
  \end{verbatim}
  \caption{Uso incorreto de estrutura condicional.}
\end{program}


\section{Estruturas de repetição}

\subsection{A estrutura ``enquanto''}

A estrutura ``enquanto'' é a mais básica e comum das estruturas de repetição. Seu funcionamento é o mesmo que
em outras linguagens populares, onde um conjunto de instruções é executado repetidamente enquanto o valor 
lógico de uma dada expressão for avaliada como ``verdadeiro''.

\begin{program}
  \begin{verbatim}
algoritmo fatorial;

variáveis
  res : inteiro;
  fat : inteiro;
  x : inteiro;
fim-variáveis

início
  imprima("Digite um número:");
  x := leia();
  
  fat := x;
  res := 1;

  enquanto x <> 0 faça
    res := res * x;
    x   := x - 1;
  fim-enquanto

  imprima("fatorial de ",fat," é igual a ",res);  
fim
  \end{verbatim}
  \caption{Exemplo de programa que utiliza a estrutura ``enquanto''.}
\end{program}


Parênteses em volta da expressão da estrutura ``enquanto'' são opcionais. Qualquer expressão que possa ter 
seu valor avaliado como numérico é uma expressão lógica válida. As expressões que não podem ser avaliadas
lógicamente são as que tem seu valor avaliado como literal. Portanto, são comandos válidos:

\begin{code}
 \begin{verbatim}
enquanto verdadeiro faça          //ok
enquanto 3+5 faça                 //ok, avalia 8 como verdadeiro
enquanto 0 faça                   //ok, avalia 0 como falso
enquanto x faça                   //ok, sendo x uma variável numérica ou lógica
enquanto ``nome'' = ``nome'' faça //ok, valor de expressão lógica (=) avaliada como verdadeiro
enquanto ``nome'' faça            //erro: literal não pode ser avaliado como lógico

  \end{verbatim}
\end{code}

\subsection{A estrutura ``para''}

A estrutura ``para'' é uma especialização da estrutura ``enquanto'', e costuma ser ensinada em cursos de programação.
Sua sintáxe é semelhante ao que se vê em literatura sobre algoritmos e estruturas de dados, entretanto, é uma sintaxe
diferente de linguagens populares como C e Java.

A estrutura ``para'' tem a seguinte forma:

\begin{code}
 para <variável numérica> de <expressão numérica> até <expressão numérica> [passo <constante inteiro>] faça
  [lista de comandos]
 fim-para
\end{code}

O uso de delimitadores (expressões de/até) constrolam os valores que a variável numérica terá no início e no fim do
laço. Tanto o controle de passos, quanto a decisão de incrementar ou decrementar a variável de controle
é feita pelo termo opicional ``passo''. Ele informa a frequência do incremento ou decremento, e 
seu valor padrão é 1. Por exemplo, para iterar o valor de uma variável numérica ``x'' de 0 até 10, de 2 em 2, escreve-se: 

\begin{code}
  \begin{verbatim}
para x de 0 até 10 passo 2 faça
  //comandos...
fim-para
  \end{verbatim}
\end{code}

Da mesma forma, para uma iteração decrescente, de 2 em 2, escreve-se:

\begin{code}
  \begin{verbatim}
para x de 0 até 10 passo -2 faça
  //comandos...
fim-para
  \end{verbatim}
\end{code}


\begin{program}
  \begin{verbatim}
algoritmo fatorial;

variáveis
  res : inteiro;
  x : inteiro;
fim-variáveis

início
  imprima("Digite um número:");
  x := leia();

  res := 1;
  para x de x até 1 passo -1 faça
    res := res * x;
  fim-para

  imprima("fatorial de ",x," é igual a ",res);
fim

  \end{verbatim}
  \caption{Exemplo de programa que utiliza a estrutura ''para``.}
\end{program}


Em comparação com a estrutura ``for'' de linguagens com sintaxe baseadas em C, há diferenças não só de sintaxe,
mas de implementação. Um ``for'' que itera sobre uma variável numérica de 0 até (incluindo) 10, ao sair do laço, 
o valor dessa variável será 11. Em G-Portugol, a variável terá o valor 10 ao sair do laço. Essa diferença acontece 
porque a sintaxe do ``para'' induz a esse comportamento, diferente da sintaxe do ``for'', que é mais detalhada
e sua estrutura induz o mesmo raciocínio que a estrutura ``enquanto/while''.

\begin{verbatim}  
//código em C
for(x = 0; x <= 10; x++) {  } 

printf("%d", x); //imprime ``11''

//--------------

//código equivalente em G-Portugol
para x de 0 até 10 faça
fim-para

imprima(x); //imprime ``10''
\end{verbatim}

Ademais, da mesma forma que o ``for'', é possível que a variável de controle tenha seu valor
alterado pelos comandos aninhados. Isso permite que o laço seja encerrado prematuramente, como também é comum
em estruturas como ``enquanto''. A utilidade dessa técnica está no fato de G-Portugol não incorporar mecanismos
para refinar o controle de laços (como ``break'' e ``continue'', encontrados em linguagens populares).
Maiores detalhes sobre a implementação no capítulo *todo*.

\newpage

\section{Funções}

Subprogramas em G-Portugol são implementados no modelo de funções, que podem ter 0 ou mais parâmetros de qualquer 
tipo, tanto primitivos quanto complexos (vetores e matrizes). Opcionalmente, podem definir valores de retorno, que 
deve ser de tipo primitivo. Tanto o retorno de dados como a passagem de argumentos são feitos \textit{por valor}.

Para retorno prematuro ou retorno de dados, a palavra chave ``retorne'' é usada. Para funções que retornam dados,
``retorne'' deve ser seguido de um operando, que é uma expressão cujo valor deve ser compatível com o tipo da função.
Já funções que não declaram um tipo de retorno expliticamente  (equivalente a funções de retorno ``void'' em C), 
``retorne'' deve ser usado sem operando.

\begin{program}[h!t]
 \begin{verbatim}
algoritmo fatorial_recursivo;

variáveis
  x : inteiro;
fim-variáveis

início
  imprima("Digite um número:");
  x := leia();  
  imprima("fatorial de ",x," é igual a ",fatorial(x));  
fim

função fatorial(z:inteiro) : inteiro
início
  se z = 1 então
    retorne 1;
  senão
    retorne z * fatorial(z-1);
  fim-se
fim 
  \end{verbatim}
  \caption{Exemplo de algoritmo que utiliza funções.}
\end{program}


\subsection{Funções internas}

Como já foi visto em exemplos anteriores, G-Portugol oferece duas funções internas: ``leia'' e ``imprima'', que
permitem uso básico de entrada e saída, respectivamente.

A função ``leia'' não recebe argumentos e retorna o valor lido da entrada padrão  (STDIN), o que significa, 
geralmente, ler os dados que o usuário digitar no teclado, seguido do caractere ``nova linha'' (em geral, associado a 
tecla ``Enter'' no teclado). O tipo de dado retornado por ``leia'' é implicitamente convertido para o tipo primitivo
exigido no contexto em que ela é usada. 

A função ``imprima'' recebe um número variável de argumentos de qualquer tipo primitivo, 
sendo que pelo menos um argumento deve ser passado. Os valores passados como argumentos são convertidos para texto,
concatenados na ordem definida e enviados para STDOUT (em geral, associado ao monitor). Não há 
retorno de valor para esta função.

Para maiores detalhes sobre funções internas, veja o capitulo sobre sua implementacao *todo*.

\begin{program}
 \begin{verbatim}
algoritmo io;

variáveis
  c: caractere;
  i: inteiro;
  r: real;
  l: literal;
  z: lógico;
  mat: matriz[2] de inteiros;
fim-variáveis

início  
  imprima("digite um caractere");
  c := leia();
  imprima("Digite um número inteiro");
  i := leia();
  imprima("Digite um número real:");
  r := leia();
  imprima("Digite um texto:");
  l := leia();
  imprima("Digite um valor lógico (\"verdadeiro\" ou \"falso\"), um número ou um texto:");
  z := leia();

  imprima("caractere: ",c,", inteiro: ",i, ", real: ",r,", texto: ",l, ", lógico: ", z,"\n");
fim
  \end{verbatim}

  \caption{Exemplo de usos das funções internas ``leia'' e ``imprima''.}
\end{program}




\capitulo{Implementação da linguagem G-Portugol}

\section{Introdução}

Ao definir uma linguagem de programação voltada para o ensino de lógica e algoritmos, vários aspectos devem ser 
considerados. Ao contrário de linguagens reais, não há preocupações como o poder expressivo da linguagem, dicionário
em inglês, acesso a recursos de sistema, etc. A preocupação central está em oferecer uma ferramenta que:

\begin{itemize}
 \item 
  reflita os processos computacionais, exigindo o mínimo de conhecimento e experiência do estudante;

  \item
  evidencie os processos relacionados com o desenvolvimento de softwares;
  
  \item
  estimule a abstração e raciocínio lógico do estudante;

\end{itemize}

\section{A linguagem}

O ponto fundamental que guia as diretrizes da linguagem G-Portugol é seu propósito educacional: ela deve expressar processos 
computacionais de forma que um leigo os compreenda sem enfatizar a si mesma. Isso é, a linguagem em si deve chamar 
o mínimo de atenção possível, fazendo com que a compreensão dos processos computacionais seja tão natural quanto ler 
sua descrição informal, ou não-estruturada. 

Esse objetivo encontra restrições, quando se leva em consideração o uso e forma popular atual da linguagem portugol,
principalmente em literaturas. É de interesse que G-Portugol ofereça compatibilidade com essas formas, o que pode gerar 
conflitos quanto a decisões de design. Portanto, embora as diretrizes marquem a base do design, muitas vezes, elas devem ser 
sacrificadas ou ajustadas para incorporar formas populares. Portanto, criar uma linguagem totalmente nova, qyue utiliza 
outros paradigmas como, por exemplo, orientação a objeto, não são de interesse embora outros paradigmas se provem mais 
eficiêntes no ensino de disciplinas computacionais.

A seguir, alguns tópicos serão comentados quanto as diretrizes por traz das formas léxicas e gramaticais da 
linguagem G-Portugol.

\subsection{Diretrizes para o design da linguagem}

\subsubsection{A linguagem deve ser totalmente em português e deve respeitar acentuações}

Linguagens de programação, em geral, não se utilizam de caracteres especiais (ex. caracteres acentuados, cedilhas,
e outros que não pertencem ao alfabeto inglês) para definição de seu dicionário, visto que são baseadas na língua inglesa. 
Portanto, letras acentuadas não são consideradas. Refletir esse aspecto em G-Portugol ignoraria seu objetivo principal.

A decisão de incorporar palavras que respeitam a língua portuguesa é importante, visto que ao modificar a linguagem
de forma a se afastar de sua língua (o português) evidenciaria excessões as quais forçariam os usuários 
(estudantes e professores) a se ater mais com o estudo da linguagem do que com o estudo da disciplina em questão.
Isso é, a ausência de acentos forçaria o estudante, por exemplo, a aprender seus termos excepcionais. Além do mais, o uso 
de termos como ``nao'', chamaria atenção constante do estudante para o fato de a palavra não estar acentuada, 
o que costuma desviar atenção do estudo.

Consequentemente, o uso de acentos permite que a linguagem seja o mais próximo do português quanto for possível,
apoiando a regra de não chamar atenção para si. Ademais, o código fica mais legível e agradável de se ler.

Além dos acentos, é exigido que as palavras-chave usadas sejam completas ou por extenso, sem permitir abreviações 
(ex. ``proc'', ``func'', ``char'', ``int'', ...), o que dificulta a leitura de programas por um leigo.

Há também decisões quanto a forma verbal de comandos e funções. Em geral, na literatura, os verbos nos algoritmos
são expressos no imperativo. Isso evidencia a característica imperativa da própria linguagem, assim como linguagens
imperativas populares como C e Pascal. Entretanto, vale notar que, mesmo em linguagens imperativas, é comum ver
programas que, escritos usando termos em português, usam verbos no infinitivo.

Evitando especular a respeito dessa prática, G-Portugol se utiliza de verbos no infinitivo para seus termos,
de forma a se aproximar das formas utilizadas nas literaturas sobre algoritmos.

\begin{quotation}
  \textit{``Programas devem ser escritos para pessoas lerem e, apenas incidentalmente, para máquinas executarem.''}
   \begin{flushright}
  -- Abelson e Sussman
  \end{flushright}
\end{quotation}

\subsubsection{A linguagem deve ter uniformidade e coerência estrutural}

Essa diretriz diz respeito a evitar excessões e surpresas a medida do possível. 
Isso significa que estruturas e comandos devem ser simples, 
claros e óbvios. Também, significa que as estruturas devem ter um formato uniforme.
Naturalmente, a linguagem portugol já detém uma parcela relevante de características que 
se acomodam nessas diretrizes, no entanto, alguns detalhes ainda merecem atenção, como a representação de blocos
estruturais. 
 
A simplicidade implica em evitar complexidades que desviam a atenção do propósito original para detalhes da linguagem. 
Isso é, apenas recursos escenciais devem fazer parte de seu núcleo. Portanto, em um primeiro momento, 
não é interessante equipar a linguagem com recursos como leitura de arquivos, alocação dinâmica de memória, 
etc. Outros recursos oferecidos por sistemas operacionais como threading estão fora de escopo.

De fato, G-Portugol deve ser uma "thin language". Manipulação de memória (por meio de variáveis), controles básicos de 
fluxo, e recursos para entrada e saída simples devem ser suficientes para evidenciar os aspectos basicos 
envolvidos no desenvolvimento de softwares. Esse argumento é baseado na previsão de que a linguagem deve ser utilizada 
apenas como uma porta de entrada para a área de programação e, portanto, recursos mais avançados devem ser vistos em 
linguagens de produção, numa etapa posterior.

\subsubsection{Deve ser configurável naquilo que diz respeito a diferentes abordagens de ensino e estilo do professor}

Essa diretriz diz respeito a permitir que a linguagem mude em certos aspectos 
(ou disponibilizar meios simples para realizar essas mudanças) de acordo com o gosto do professor, 
ou como modo de adapatar a forma de portugol de uma dada literatura. 
Dialetos e formas da linguagem portugol variam de literatura para literatura, e pode ser interessante permitir que a 
linguagem se adapte.

Entre os aspectos que podem ser adaptados com facilidade se encontram os termos léxicos (palavras-chave, operadores,etc),
e algumas formas de expressar estruturas, como algumas declarações e enunciados.

Por exemplo, pode ser interessante que, para se declarar uma varíavel, não se use um bloco iniciado por 
``variáveis'' e terminado por ``fim-variáveis'', mas como um bloco parecido com a declaração de variáveis
em Pascal, ou em C (que sequer exige delimitação de bloco de variáveis).

\section{Formato Estrutural}

A forma de um programa escrito em G-Portugol tem o seguinte formato:

\begin{itemize}
 \item 
  declaração do algoritmo

  \item
  declaração de variáveis globais

  \item
  bloco principal

  \item
  declaração de funções
\end{itemize}


  Esse formato não está salvo de possíveis mudanças futuras, visto que um importante aspecto que guia o design
  da linguagem é sua compatibilidade com as formas populares de portugol e este, evidentemente, está sujeito
  a mudanças.
  
  A seguir, alguns pontos serão discutidos a respeito do formato da linguagem.

\subsection{Declaração do algoritmo}

  A declaração do algoritmo não influencia o programa ou sua execução, visto que é apenas uma sessão informativa no código
  que, embora não seja um comentário, tem o mesmo efeito prático.
  A adoção dessa declaração pode ser discutida, e foi escolhida por ser bastante utilizada em literaturas.
  
\subsection{Declaração de variáveis}

  Como visto no capítulo 2, essa declaração é opicional, e seu formato pode ser visto no exemplo a seguir:

\begin{verbatim}
variáveis
  x : inteiro;
fim-variáveis
\end{verbatim}

  Esse formato diferente de linguagens como Pascal e C.
  Em Pascal, o bloco não tem um delimitador final (como ``fim-variáveis'') e em C, não existe qualquer delimitador.

  Delimitar o bloco permite maior consistência com outras estruturas, que são delimitadas em seu início e fim.

  * tipos escolhidos, matrizes, vetores, lack of struct, 
  * declaracao de variaveis locais


  
\subsection{Bloco Principal}


  Muitas linguagens oferecem delimitadores de blocos e, de alguma forma, devem oferecer um ``entry point'' 
  (ponto de entrada), de onde se inicia a execução do programa. O ponto de entrada pode ser uma função
  ou um bloco anonimo. Na literatura, em geral, o bloco principal é delimitado pelos termos ``início'' e 
  ``fim''. Essa é uma abordagem interessante que, em contra ponto com uma função como ponto de entrada,
  não obriga o usuário a ignorar o que vem a ser uma função ou estudar seus conceitos antes de ter aprendido
  conceitos básicos.
  
  Sendo assim, G-Portugol se utiliza de ``início'' e ``fim'' como delimitadores do bloco principal.
  Essa decisão mantém um nível satisfatório de coerência com o bloco de variáveis globais e estruturas de controle,
  embora não sejam intimamente relacionados.

  \subsubsection{Estruturas de Controle}

  Estruturas de controle, usualmente são formados por um cabeçalho seguido por um bloco de comandos.
  Embora os delimitadores do bloco não sejam ``início'' e ``fim'', há um grau de semelhança: o delimitador inicial 
  é omitido e o delimitador final é o termo ``fim-'' seguido do nome da estrutura.   

  Vale ressaltar que não se faz imposição sobre a identação do código. Esse recurso pode ser interessante,
  de forma a promover maior consistencia e coerência estrutural. Portanto, embora possa ser vantajoso,
  sua implementação pode ser discutida para versões futuras.

  No cabeçalho das estruturas como ``enquanto'' e ``se, as expressões não precisam ser delimitadas por parêntesis.


  \subsubsection{Expressões}

  Expressões são operações que sintetizam, ao final, um valor. Em geral constituem operações aritiméticas
  e os termos podem ser variáveis, constantes ou chamadas a funções.

  Em G-Portugol, não há coerção (''casting``) de tipos expliticamente. Todos os tipos numéricos
  (inteiro, real, lógico e caractere) são compativeis entre si, no entanto, dados podem ser perdidos
  durante a conversão (como por exemplo, de real para inteiro).
  
  A precedencia de operadores segue a seguinte tabela (da menor precedência para a maior):


% \begin{table}[ht]
% \begin{center}
%   \begin{tabular}{|l|l|}
%     \hline
%     \multicolumn{2}{|c|}{Precedência de Operadores} \\
%     \hline
%       Operador & Nome \\
%     \hline
%     ou, ||  & OR lógico  \\
% %     e, \&\&  & AND lógico \\
%     | & OR binário \\
% %     \^ &  XOR binário \\
% %     \& & AND binário \\
%     =, <> & op. de igualdade \\
%     >, >=, <, <= & op. relacionais \\
%     +, - & op. aritméticos soma e subtração \\
%     *, /, \% & op. aritméticos multi, div, mod \\
%     +, -, \thicksim, não & op. unários pos,neg,NOT binário e lógico \\
%     \hline
%   \end{tabular}
%   \label{tb_tipos_primitivos}
%   \caption{Precedência de Operadores}
% \end{center}
% \end{table}


  É vetado o uso de enunciados como atribuição em locais onde se espera uma expressão. A avaliação de expressões
  é discutida a seguir.


  *operadores e operandos
  *precendencia e associatividade


  *sobre a semantica (castings, etc)

  *promoções de tipos e castings automaticos (inteiro para real, real para inteiro)
  *avaliações aritméticas
  *avaliações lógicas 
  *literais
    *reais usam ``.'' e não ``,''
  
  *matrizes nao sao aceitas como lvalue
  mat := mat2 !!

  subscritos de matrizes são expressões que devem ser avaliadas como numeros inteiros.

\section{Funções}
No contexto de uma função, variáveis locais com o mesmo nome que variáveis globais são permitidas, sendo que as últimas
são impossibilitadas de serem usadas, enquanto o contexto durar.

  *Não suporte a funções aninhadas
  *suporte a recursão
  *retorno apenas para tipos primitivos.

  excecoes:
  blocos de variaveis
  *excessão, nos blocos de variáveis locais em escopo de funcao

  declaracao de multiplas variaveis em blocos VS. declaracao de parametros:
    variavies
      x,y : inteiro; //ok

    função f(x,y:inteiro); //erro



\section {Funções internas}

  \subsection{A função ``imprima''}
    argumentos variaveis
    retorno: null
    minimo: um arg

  *As funcoes leia e imprima:
    leia() retornando tipos variaveis
    restrição de leia() usado em expressões com multiplos termos
    imprima() recebendo numero variavel de argumentos.



  \subsection{A função ``leia''}

    limitacoes da v1: nao pode ser usado em expressões binarias
        
    retorna o valor convertido para o tipo que o contexto exige.
      ex: mat[leia()] //inteiro
    
    Conversoes:      

      Inteiros como lvalue (os mesmos valem para float):
      (inteiro) := leia(); ``123 456'' => ``123''
      (inteiro) := leia(); ``abc'' => ``0''
      (inteiro) := leia(); ``123s'' => ``123''
  
      Logico:
      (logico) := leia(); ``falso'' => ``falso''
      (logico) := leia(); ``0'' => ``0''
      (logico) := leia(); ``falso 123'' => ``verdadeiro''
      (logico) := leia(); ``0 umdoistrez '' => ``verdadeiro''
      e demais: ``verdadeiro''
    
  Preferencia ao uso da função ``leia'' sem parametros:
    Comentarios e justificativa contra o uso de ``void leia(x)''

\capitulo{O programa GPT}

\section{Intrudução}
  
  traducao (C)
  interpretacao/depuracao
  compilacao (ELF)

  Comportamento uniforme entre os tipos de execução
    *programa compilado em C deve ter o mesmo comportamento do programa interpretado


\section{Tratamento de erros}

  *sobre o tratamento de erros. 
    -Importancia de ``verbose''

	tratamento de erros:
será que atrapalha mais do que ajuda continuar a analise sintatica apos errors encontrados?
Muitos erros seguintes ao primeiro podem acabar atrapalhando mais.
Ao catch[], pode-se lancar um custom exception, a ser recuperado em main.c
Fazer disso uma opcao?
A dificuldade em deixar as mensagens de erro uniformes, ao tentar elaborar tratamentos de erros mais detalhados e prestativos.


\section{Tradução para C}


  \subsection{Limitações}
      *nomes de identificadores em conflito com os nomes em C/glibc

	*diferencas:
		*array bound check
		*precedencia de operadores de C vs. precendencia de operadores de G-Portugol (pesquisar para saber se sao equivalentes)

\section{Interpretação de código}

  \subsection{Erros de execução (runtime errors)}
    boundcheck, etc...

  \subsection{Depuração iterativa}

      *estrutura do XML
      *command line debugger.

\section{Compilação para codigo nativo (ELF)}

\section{Depuração interativa}

  
%%%
%  Apendice
%   *gramatica da linguagem
%%%

\end{document}
