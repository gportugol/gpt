% TODO: -rever referencias a implementação da gramatica%       
%       -Glossario e padronizacao de termos: uso de vetor e matriz,
%        significando coisas distintas, e o que significam
%       -Convenções (uso de shell unix, etc)
%       -Mudar reticencias "..." pelo comando de reticencias

\documentclass[a4paper,10pt]{report}
\makeatletter

% page setup
\oddsidemargin  0.0in
\evensidemargin 0.0in
\textwidth      6.5in
\headheight     0.2in
\topmargin      0.0in
\textheight=9.0in

\pagestyle{myheadings}     % Go for customized headings
\newcommand{\capitulo}[1]  % Re-define the chaptering command
        { 
          \chapter{#1}

          %http://www.devdaily.com/blog/Content/2/18/408/
          %\lhead{\nouppercase{\rightmark} (\nouppercase{\leftmark})}

          \lhead{Capítulo \thechapter. \nouppercase{\leftmark} }
          \chead{}
          \rhead{}
          \lfoot{G-Portugol}
          \cfoot{}
          \rfoot{\thepage}
          \renewcommand{\headrulewidth}{0.4pt}
          \renewcommand{\footrulewidth}{0.4pt}
          \renewcommand{\sectionmark}[1]{%
            \markboth{#1}{}
          }

          % seta o footer das paginas de capitulo (sem isso, aparece o pagenum centralizado apenas)
          \fancypagestyle{plain}{%
            \fancyhead{} % remoev o header
            \renewcommand{\headrulewidth}{0pt} % e a linha
          }
        }


\usepackage{fancyhdr} %Declares the package fancyhdr
\pagestyle{fancy} %Forces the page to use the fancy template

\fancypagestyle{empty}
\fancyhf{} %Clears all header and footer fields, in preparation.
\fancyhead[EO]{\thepage} %Even and Odd pages: set the \thepage value
\fancyhead[C]{} %clear center text
\fancyhead[LO]{\rightmark} %Displays the lower-level (chapter) information - as


\usepackage[brazilian]{babel} %traduz data, ``capitulo'', etc...
\usepackage[latin1]{inputenc} %permite acentos diretamente
\usepackage[T1]{fontenc} %to get the hyphenation right.
%\usepackage{times}
%\usepackage{aeguill}

% \usepackage{hyperref} %referencias para PDF

\usepackage{float}

\floatstyle{ruled}
\newfloat{program}{thp}{lop}
\floatname{program}{Programa}

\floatstyle{plain}
\newfloat{code}{thp}{lop}
\floatname{code}{Codigo}

\renewcommand{\rmdefault}{phv} %helvetica


% \def\thickhrulefill{\leavevmode \leaders \hrule height 1pt\hfill \kern \z@}
\renewcommand{\maketitle}{

  \begin{titlepage}%

    %% remove footer (sem isso, aparece o numero da pagina)
    \fancyhf{} 
    \fancypagestyle{empty}{%
      \fancyhead{} % remoev o header
      \renewcommand{\headrulewidth}{0pt} % e a linha
    }

    
    \let\footnotesize\small
    \let\footnoterule\relax
    \parindent \z@
    \reset@font
    \null
    \vskip 50\p@
    \begin{center}
      \hrule
      \vskip 1pt
      \hrule
      \vskip 1pt
      {\huge \bfseries \strut \@title \strut}\par
      \vskip 1pt
      \hrule
      \vskip 1pt
      \hrule
      
      \vskip 5pt 
      \Large Manual da versão \@version

    \end{center}
    \vskip 5\p@
    \vfil
    \null

    \vskip 350pt
    \begin{flushright}
    {\Large \@author \par}
    {\Large \@email \par}
    \vskip 100pt
    {\Large \@date\par}    
    \end{flushright}  

  \end{titlepage}%

  \setcounter{footnote}{0}%

}
%\makeatother %nao sei pra que isso serve...

\def\email#1{\def\@email{#1}}
\def\version#1{\def\@version{#1}}

\title{G-Portugol}
\version{v1.0}
\author{Thiago Silva}
\email{\texttt{thiago.silva@kdemail.net}}


\usepackage[pdftex,                %%% hyper-references for pdflatex
    bookmarks=true,%                   %%% generate bookmarks ...
    bookmarksnumbered=true,%           %%% ... with numbers
    hypertexnames=false,%              %%% needed for correct links to figures !!!
    breaklinks=true,%                  %%% break links if exceeding a single line
    colorlinks=true,
    linkcolor=blue,
    pdfborder={0 0 0}]
  {hyperref} %%% blue frames around links


\hypersetup{
 pdfauthor = {\@author},
 pdftitle = {\@title},
 pdfsubject = {Linguagem de programação},
 pdfkeywords = {portugol, programação},
 pdfcreator = {LaTeX with hyperref package},
 pdfproducer = {dvips + ps2pdf}
}

\begin{document}

\maketitle
\tableofcontents




\begin{abstract}

Esse não é um livro que ensina programação, algoritmos ou lógica. Seu objetivo é
servir de manual para a linguagem G-Portugol e ferramentas relacionadas.
Portanto, ele assume que o leitor seja versado em linguagens de programação
e desenvolvimento de software.

\end{abstract}



%%%%%%%%%%%%%%%%% Introducao



\capitulo{Introdução}
\label{ch:intro}

G-Portugol é um dialeto da linguagem portugol (ou portugês estruturado), que
é muito usada para descrever algoritmos em português, de forma livre
e espontânea. Em geral, livros dedicados ao ensino de algoritmos, lógica
e estruturas de dados utilizam alguma forma dessa linguagem. 

A proposta de G-Portugol é disponibilizar uma implementação da
linguagem portugol, fornecendo ferramentas que ofereçam recursos de edição,
compilação, execução e depuração de programas escritos nessa linguagem, de forma
a favorecer estudantes que dão os primeiros passos no aprendizado de
desenvolvimento de softwares, bem como professores que ensinam disciplinas
relacionadas a computação. Portanto, seu foco é primariamente didático.

Se encontram disponíveis atualmente um tradutor/interpretador para a
linguagem (GPT) e um ambiente visual simples (GPTEditor) que permite execução
e depuração de programas escritos em G-Portugol. 

A seguir é apresentado os assuntos abordados nos capítulos seguintes:

\begin{itemize}
 \item 
  Capítulo 2: pretende discutir as características gerais da linguagem. 

  \item
  Capítulo 3: aborda a programação em G-Portugol, suas estruturas e recursos, utilizando exemplos ilustrativos e 
  comparando com linguagens populares. Embora o capítulo trate da programação, ele não tem como objetivo explicar 
  programação em si ou a teoria/historia por traz das estruturas abordadas. 

  \item
  Capítulo 4: trata da implementação da linguagem. Discute as decisões de design e recursos oferecidos por G-Portugol.

  \item
  Capítulo 5: descreve o programa GPT, o tradutor/interpretador e depurador para a linguagem G-Portugol.

\end{itemize}

No apêndice deste livro pode ser encontrado a gramática da linguagem G-Portugol.



%%%%%%%%%%%%%%%%% Caracteristicas Gerais



\capitulo{Características Gerais}
\label{ch:caracgerais}

A linguagem em si não difere fundamentalmente ou apresenta novidades em relação ao uso popular de 
portugol. Semelhante à linguagens como Pascal e C, é uma linguagem imperativa, com comandos de 
controle de fluxo, manipulação de dados e recursos de entrada e saída básicos.

\section{Tipos de dados}

Tipos primitivos como inteiro e literal são suportados. Além das estruturas de
controle, subprogramas são suportados no modelo de funções parametrizadas com
retorno de dados primitivos. Entre os tipos primitivos, se encontram:

\begin{table}[ht]
\begin{center}
  \begin{tabular}{|l|l|}
    \hline
    \multicolumn{2}{|c|}{Tipos primitivos} \\
    \hline
      Tipo & Exemplos \\
    \hline
    inteiro & 19 \\
    real & 2.5 \\
    caractere & 'a' \\
    literal & ``uma frase'' \\
    lógico & verdadeiro \\
    \hline
  \end{tabular}
  \label{tb_tipos_primitivos}
  \caption{Tipos de dados primitivos}
\end{center}
\end{table}

Com esses tipos, pode-se criar conjuntos como vetores ou matrizes ``n''
dimensionais. Tipos mais complexos não são suportados.
\newline
\newline
\newline

\section{Estruturas de controle}

O conjunto de estruturas de controle são os mais primitivos. Uma
estrutura condicional (se/senão) e duas estruturas de repetição (enquanto/para)
são suportadas. Embora a estrutura ``para'' seja uma especialização de um laço
simples como o ``enquanto'', ela foi implementada, visto que uma variedade
de livros e muitos professores os discutem.

\begin{table}[h!t]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \multicolumn{2}{|c|}{Estruturas de repetição} \\
      \hline
        Estrutura & Tipo \\
      \hline
      se/então/senão/& condicional \\
      enquanto & repetição \\
      para & repetição \\
      \hline    
    \end{tabular}

    \label{tb_estruturas_de_repeticao}
    \caption{Estruturas de repetição}
  \end{center}
\end{table}


\section{Subprogramas (funções)}

Subprogramas são como funções em C. Podem receber qualquer número de parâmetros, sejam tipos primitivos
ou vetores, e podem retornar valores primitivos. Entretanto, não é permitido declarar funções aninhadas ou
funções com parâmetros variáveis. Vale ressaltar que passagem de parâmetros é sempre feita por 
\textit{valor}.



%%%%%%%%%%%%%%%%% Programando em G-Portugol



\capitulo{Programando em G-Portugol}
\label{ch:programando}

A proposta desse capítulo é mostrar os elementos da linguagem G-Portugol usando programas como exemplos. Não 
é um capítulo sobre como programar, nem tem como intuito ensinar algorítmos. Portanto, é esperado que o 
leitor seja familiarizado com programação.

\section{Olá Mundo}

Mantendo a tradição, vamos criar nosso primeiro programa. O propósito dele será exibir na tela o 
texto "Olá mundo". Crie um arquivo  chamado "olamundo.gpt" com o seguinte 
conteúdo:

\begin{program}
  \begin{verbatim}
/* 
  Nosso primeiro programa 
*/
  
algoritmo olamundo;
  
início
  imprima("Olá mundo!");
fim
  \end{verbatim}
  \caption{``Olá Mundo'' em G-Portugol.}
\end{program}

\noindent 
Após salvar o arquivo, digite o seguinte na linha de comando:

\begin{verbatim}
$ gpt -o olamundo olamundo.gpt
\end{verbatim}

Esse comando compila o algoritmo e salva o arquivo binário resultante como
``olamundo'' no diretório atual. Pode-se, agora, executar o programa da seguinte
forma:

\begin{verbatim}
$ ./olamundo
Olá mundo! 
\end{verbatim}

Como já deve ter assumido, comentários ao estilo C (/**/) e C++ (//) são
permitidos e o que estiver entre aspas duplas (") é tratado como uma string ou
constante literal. Escapes são permitidos como EOL ($\backslash$n), tabulação
($\backslash$t) dentre outros. Não é permitido a concatenação em multiplas
linhas como na linguagem C:

\begin{verbatim}
  imprima("Isso é uma "
          "Concatenação"); //erro!
\end{verbatim}

Outro detalhe é a pontuação. Da mesma forma que em C, o ``;'' é utilizado como
finalizador de enunciados.

\section{Variáveis}

A declaração de variáveis deve ser feita dentro de um bloco específico, que deve aparecer logo após a 
declaração do algoritmo. O bloco é iniciado pela palavra-chave ``variáveis'' (sim, com acento) e 
termina com a palavra chave ``fim-variáveis''. Pelo menos uma variável deve
ser declarada dentro do bloco (embora o bloco em si seja opcional) e apenas
um bloco em escopo global deve ser declarado. Eis um exemplo para estudo:

\begin{program}  
  \begin{verbatim}  
algoritmo inutil;

variáveis
  x    : inteiro;
  nome : literal
fim-variáveis

início
fim
  \end{verbatim}  
  \caption{Declaração de variáveis globais.}
  \label{programa_inutil}
\end{program}
 

\subsection{Variáveis primitivas}

Variáveis primitivas são declaradas seguindo o seguinte modelo:

\begin{verbatim}
<identificador> [, identificador]* : <tipo>; 
\end{verbatim}

Como pode-se notar, é parecido com Pascal. Assim que um programa é executado, todas as variáveis declaradas são 
iniciadas com um valor nulo ou ``0'' automaticamente. Vale ressaltar que constantes (const, final, etc) não são 
suportados. Os tipos primitivos suportados encontram-se na tabela \ref{tb_tipos_primitivos}

A fim explorar melhor os aspectos da declaração, seguem-se alguns comentários a
respeito do último exemplo (programa \ref{programa_inutil})

\begin{itemize}
 \item 
  Observe que o nome do algoritmo (``inutil'') não tem acento. Se declarar o
algoritmo como ``inútil'' e tentar compilar o código, o seguinte erro será
exibido:

  \textbf{Linha: 1 - ``inútil'' não pode ter caracteres especiais.}

  Portanto, identificadores (nomes de variáveis, funções e do algoritmo) não
  podem ter acentos ou caracteres especiais. A definição de um identificador em
  G-Portugol é equivalente ao das linguagens populares: uma letra (a-z ou
  A-Z) seguido de qualquer número de letras ou  números (e underscores).
  Cedilhas, portanto, também não formam identificadores válidos. 

 \item 
  O segundo ponto, é a palavra-chave ``variáveis'': ela tem acento, e isso é permitido e de propósito. 

  \item
  O terceiro, é a definição do bloco e sua (falta de) semelhança com o Pascal. Todas os blocos em G-Portugol 
  tentam seguir o formato ``nome/fim-nome'', em favor da uniformidade e em detrimento de exceções linguísticas 
  que confundem os estudantes.

  \item 
  E, finalmente, o quarto ponto é a ausência de código entre ``início'' e ``fim''. 
  O programa não é obrigado a ter enunciados ou comandos. Meros detalhes... 
\end{itemize}

  Para maiores detalhes, veja o capítulo \ref{ch:impl}, sobre a implementação
da linguagem.


\subsection{Vetores e matrizes}


Vetores e matrizes ``n'' dimensionais de tipos primitivos são suportados. Um
exemplo de declaração de uma matriz:


\begin{verbatim}
variáveis
   bitset : matriz[10] de lógicos;
   quadr : matriz[4][4] de inteiros;
fim-variáveis 
\end{verbatim}

O tipo do vetor ou matriz é dado pelo nome do tipo no plural (``inteiros'' para tipo inteiro, ``literais'' 
para tipo literal, etc). Os subscritos na declaração (delimitados por ``[]'') indicam o tamanho da matriz, 
e sua dimensão é informada pelo numero de subscritos. Portanto, ``bitset'' é um vetor de 10 valores lógicos,
enquanto ``quadr'' é uma matriz bidimensional, onde as duas dimensões tem tamanho 4.

É importante observar que matrizes são ``0 based'', isso é, iniciam no
índice 0. Logo, a matriz ``bitset'' pode ser usada do indice 0 até o indice 9
(inclusive). Seu indice 10 não é válido e seu uso poderá acarretar em erros de
execução (\textit{runtime errors}). Matrizes, assim como variáveis de tipos
primitivos, são inicializadas com o valor ``0'' ou ``nulo'' em todas as suas
posições. Quando usadas como argumentos de funções, matrizes são passadas
\textit{por valor}.

\section{Estruturas condicionais}

Por enquanto, apenas a estrutura se/então/senão é suportada. 
Eis um algoritmo simples que verifica se o usuário é maior de idade:

\begin{program}
 \begin{verbatim}
algoritmo idade;

variáveis
  idade : inteiro;
  nome : literal;
fim-variáveis

início
  imprima("Digite seu nome:");
  nome := leia();

  imprima(nome, ", digite sua idade:");
  idade := leia();  

  se idade >= 18 então    
    se idade < 60 então
      imprima("adulto!");
    senão
      imprima("ancião", '!');
    fim-se
  senão
    imprima("menor", "!");
  fim-se
fim
  \end{verbatim}
  %\label{programa_exemplo_condicional}
  \caption{Exemplo de programa que utiliza estrutura condicional.}
\end{program}

Alguns pontos a serem considerados:


\begin{itemize}
  \item 
  O nome do algoritmo é ``idade'', assim como o nome de uma variável. Não há
conflitos.

  \item
  O operador de atribuição é o pascal-like ``:=''.4

  \item
  A função interna ``leia'' pode ser usada por variáveis de qualquer
tipo primitivo. 

  \item
  A função ``imprima'' recebe um número de argumentos variáveis, que podem ser
  constantes literais, variáveis primitivas ou indices de vetores/matrizes. Os
  valores são concatenados e adicionados de um caractere EOL (end of line, ou
  fim de linha).

  \item
  Já vimos que strings/literais constantes são denotados por texto entre aspas duplas ("). Tal qual em C, 
  um caractere entre aspas simples (') é um caractere constante que, da mesma forma, pode permitir escapes como 
  '$\backslash$n'.

  \item
  Assim como a palavra-chave ``variáveis'', ``então'' e ``senão'' devem ser acentuadas. 

  \item 
  Parêntesis ao redor da expressão da estrutura ``se/então'' são opicionais.

  \item
  Como em ``variáveis/fim-variáveis'', blocos ``se'' tem seus respectivos e obrigatórios ``fim-se''. 
  Não há a opção de ignorar a definição do bloco quando apenas um enunciado é
  usado, como na linguagem C onde o uso de ``{}'' é opcional. Também, não há 
  imposições  sobre a indentação.

\end{itemize}

\begin{program}
  \begin{verbatim}
//código inválido: faltando fim-se
algoritmo se_invalido;

início
  se x = 2 então
    imprima("ok");
  imprima("estou dentro ou fora do bloco \"se\"?");
fim 
  \end{verbatim}
  \caption{Uso incorreto de estrutura condicional.}
\end{program}


\section{Estruturas de repetição}

\subsection{A estrutura ``enquanto''}

A estrutura ``enquanto'' é a mais básica e comum das estruturas de repetição. Seu funcionamento é o mesmo que
em outras linguagens populares, onde um conjunto de instruções é executado repetidamente enquanto o valor 
lógico de uma dada expressão for avaliada como ``verdadeiro''.

\begin{program}
  \begin{verbatim}
algoritmo fatorial;

variáveis
  res : inteiro;
  fat : inteiro;
  x : inteiro;
fim-variáveis

início
  imprima("Digite um número:");
  x := leia();
  
  fat := x;
  res := 1;

  enquanto x <> 0 faça
    res := res * x;
    x   := x - 1;
  fim-enquanto

  imprima("fatorial de ",fat," é igual a ",res);  
fim
  \end{verbatim}
  \caption{Exemplo de programa que utiliza a estrutura ``enquanto''.}
\end{program}


Assim como na estrutura ``se/então'', parênteses em volta da expressão são
opcionais. Qualquer expressão que possa ter seu valor avaliado como numérico é
uma expressão lógica válida. As expressões que não podem ser avaliadas
lógicamente são as que tem seu valor avaliado como literal. Portanto, são
comandos válidos:

 \begin{verbatim}
enquanto verdadeiro faça          //ok
enquanto 3+5 faça                 //ok, avalia 8 como verdadeiro
enquanto 0 faça                   //ok, avalia 0 como falso
enquanto x faça                   //ok, sendo x uma variável numérica ou lógica
enquanto ``nome'' = ``nome'' faça //ok, valor de expressão lógica (=) avaliada como verdadeiro
enquanto ``nome'' faça            //erro: literal não pode ser avaliado como lógico

  \end{verbatim}


Para maiores detalhes sobre expressões, veja a seção \ref{sec:expr}.

\subsection{A estrutura ``para''}

A estrutura ``para'' é uma especialização da estrutura ``enquanto'', e costuma ser ensinada em cursos de programação.
Sua sintáxe é semelhante ao que se vê em literatura sobre algoritmos e estruturas de dados, entretanto, é uma sintaxe
diferente de linguagens populares como C e Java.

A estrutura ``para'' tem a seguinte forma:

\begin{verbatim}
 para <variável> de <expressão> até <expressão> [passo <inteiro>] faça
  [lista de comandos]
 fim-para
\end{verbatim} 


Onde:
\begin{itemize}
 \item 
  ``variável'' deve ser uma variável numérica;
  \item
  ``expressão'' deve ser uma expressão numérica
  \item
  ``passo'', se existir, deve ser seguido por um inteiro constante.
\end{itemize}
  
As expressões de/até constrolam os valores que a variável numérica terá no
início e no fim do laço, respectivamente. Tanto o controle da frequência, quanto
a decisão de incrementar ou decrementar a variável de controle é feita pelo
termo opicional ``passo'', e seu valor padrão é 1. Por exemplo, para iterar o
valor de uma variável numérica ``x'' de 0 até 10, de 2 em 2, escreve-se: 

  \begin{verbatim}
para x de 0 até 10 passo 2 faça
  //comandos...
fim-para
  \end{verbatim}


Da mesma forma, para uma iteração decrescente, de 2 em 2, escreve-se:


  \begin{verbatim}
para x de 0 até 10 passo -2 faça
  //comandos...
fim-para
  \end{verbatim}



\begin{program}
  \begin{verbatim}
algoritmo fatorial;

variáveis
  res : inteiro;
  x : inteiro;
fim-variáveis

início
  imprima("Digite um número:");
  x := leia();

  res := 1;
  para x de x até 1 passo -1 faça
    res := res * x;
  fim-para

  imprima("fatorial de ",x," é igual a ",res);
fim

  \end{verbatim}
  \caption{Exemplo de programa que utiliza a estrutura ''para``.}
\end{program}


Em comparação com a estrutura ``for'' de linguagens com sintaxe baseadas em C,
há diferenças não só de sintaxe, mas de implementação. Um ``for'' que itera
sobre uma variável numérica de 0 até (incluindo) 10, ao sair do laço, o
valor dessa variável será 11. Em G-Portugol, a variável terá o valor 10 ao
sair do laço. Essa diferença acontece porque a sintaxe do ``para'' induz a esse
comportamento, diferente da sintaxe do ``for'', que tem um aspecto de mais
baixo nível.

\begin{verbatim}  
//código em C
for(x = 0; x <= 10; x++) {  } 

printf("%d", x); //imprime ``11''

//--------------

//código equivalente em G-Portugol
para x de 0 até 10 faça
fim-para

imprima(x); //imprime ``10''
\end{verbatim}

Ademais, da mesma forma que o ``for'', é possível que a variável de controle tenha seu valor
alterado pelos comandos aninhados. Isso permite que o laço seja encerrado prematuramente, como também é comum
em estruturas como ``enquanto''. A utilidade dessa técnica está no fato de G-Portugol não incorporar mecanismos
para refinar o controle de laços (como ``break'' e ``continue'', encontrados em linguagens populares).

\section{Funções}

Subprogramas em G-Portugol são implementados no modelo de funções, que podem
ter zero ou mais parâmetros de qualquer tipo, tanto primitivos quanto
complexos (vetores e matrizes). Opcionalmente, elas podem definir valores de
retorno, que deve ser de tipo primitivo. Tanto o retorno de dados como a
passagem de argumentos são feitos \textit{por valor}.

Para retorno prematuro ou retorno de dados, a palavra chave ``retorne'' é usada. Para funções que retornam dados,
``retorne'' deve ser seguido de um operando, que é uma expressão cujo valor deve ser compatível com o tipo da função.
Já funções que não declaram um tipo de retorno expliticamente  (equivalente a funções de retorno ``void'' em C), 
``retorne'' deve ser usado sem operando.

\begin{program}[h!t]
 \begin{verbatim}
algoritmo fatorial_recursivo;

variáveis
  x : inteiro;
fim-variáveis

início
  imprima("Digite um número:");
  x := leia();  
  imprima("fatorial de ",x," é igual a ",fatorial(x));  
fim

função fatorial(z:inteiro) : inteiro
início
  se z = 1 então
    retorne 1;
  senão
    retorne z * fatorial(z-1);
  fim-se
fim 
  \end{verbatim}
  \caption{Exemplo de algoritmo que utiliza funções.}
\end{program}


\subsection{Funções internas}
\label{sec:func_internas}

Como já foi visto em exemplos anteriores, G-Portugol oferece duas funções internas: ``leia'' e ``imprima'', que
permitem uso básico de entrada e saída, respectivamente.

A função ``leia'' não recebe argumentos e retorna o valor lido da entrada padrão
(``STDIN''), o que significa, geralmente, ler os dados que o usuário digitar
no teclado, seguido do caractere ``nova linha'' (em geral, associado a
tecla ``Enter'' no teclado). O tipo de dado retornado por ``leia''
é implicitamente convertido para o tipo primitivo exigido no contexto em que ela
é usada.

A função ``imprima'' recebe um número variável de argumentos de qualquer tipo
primitivo, sendo que pelo menos um argumento deve ser passado. Os
valores passados como argumentos são convertidos para texto, concatenados
na ordem definida e enviados para ``STDOUT'' (em geral, associado ao
\textit{display} ou monitor). Não há retorno de valor para esta função.

\begin{program}
 \begin{verbatim}
algoritmo io;

variáveis
  c: caractere;
  i: inteiro;
  r: real;
  l: literal;
  z: lógico;
  mat: matriz[2] de inteiros;
fim-variáveis

início  
  imprima("digite um caractere");
  c := leia();
  imprima("Digite um número inteiro");
  i := leia();
  imprima("Digite um número real:");
  r := leia();
  imprima("Digite um texto:");
  l := leia();
  imprima("Digite um valor lógico (\"verdadeiro\" ou \"falso\"), um número ou um texto:");
  z := leia();

  imprima("caractere: ",c,", inteiro: ",i, ", real: ",r,", texto: ",l, ", lógico: ", z,"\n");
fim
  \end{verbatim}

  \caption{Exemplo de usos das funções internas ``leia'' e ``imprima''.}
\end{program}



%%%%%%%%%%%%%%%%% Implementação da linguagem G-Portugol




\capitulo{Implementação da linguagem G-Portugol}
\label{ch:impl}

\section{Introdução}

Ao definir uma linguagem de programação voltada para o ensino de lógica e
algoritmos, vários aspectos devem ser considerados. Ao contrário de linguagens
de produção, não há preocupações como o poder expressivo da linguagem,
dicionário em inglês, acesso a recursos de sistema, etc. A preocupação central
está em oferecer uma ferramenta que:

\begin{itemize}
 \item 
  reflita os processos computacionais, exigindo o mínimo de conhecimento e experiência do estudante;

  \item
  evidencie os processos relacionados com o desenvolvimento de softwares;
  
  \item
  estimule a abstração e raciocínio lógico do estudante;

\end{itemize}

\section{A linguagem}

O ponto fundamental que guia as diretrizes da linguagem G-Portugol é seu
propósito educacional: ela deve expressar processos computacionais de forma
que um leigo os compreenda sem enfatizar a si mesma. Isso é, a linguagem em
si deve chamar o mínimo de atenção possível, fazendo com que a compreensão
dos processos computacionais seja tão natural quanto ler sua descrição
informal, ou não-estruturada. 

Esse objetivo encontra restrições, quando se leva em consideração a natureza
das linguagens artificiais e o uso e forma popular atual da linguagem
portugol, principalmente em literaturas. É de interesse que G-Portugol
ofereça compatibilidade com essas formas, o que pode gerar conflitos quanto
a decisões de design e restringir suas características. Portanto, embora
as diretrizes marquem a base do design, muitas vezes, elas devem ser
sacrificadas ou ajustadas para incorporar formas populares.

É interessante ressaltar que criar uma linguagem totalmente nova, que
utiliza outros paradigmas como, por exemplo, orientação a objeto, possa ser
interessantes e, talvez, mais eficientes como ferramentas de ensino,
mas G-Portugol está, no momento, comprometida com a compatibilidade.

A seguir, alguns tópicos serão comentados quanto as diretrizes por traz
das formas léxicas e gramaticais da linguagem G-Portugol.

\subsection{Diretrizes para o design da linguagem}

\subsubsection{A linguagem deve ser totalmente em português e deve respeitar acentuações}

Linguagens de programação, em geral, não se utilizam de caracteres especiais
(ex. caracteres acentuados, cedilhas, e outros que não pertencem ao
alfabeto inglês) para definição de seu dicionário, visto que são baseadas
na língua inglesa. Portanto, letras acentuadas não são consideradas. Refletir
esse aspecto em G-Portugol ignoraria seu objetivo principal.

A decisão de incorporar palavras que respeitam a língua portuguesa é
importante, visto que modificar a linguagem de forma a se afastar de
sua língua natural (o português) evidencia excessões as quais forçariam os
usuários (estudantes e professores) a se ater mais com o estudo da linguagem do
que com o estudo da disciplina em questão. Isso é, a ausência de acentos, por
exemplo, obriga o usuário a aprender seus termos excepcionais. Além do mais,
o uso de termos como ``nao'', chama a atenção constante do usuário para o fato
de a palavra não estar acentuada, o que costuma desviar atenção do estudo.

Consequentemente, o uso de acentos permite que a linguagem seja o mais próximo
do português quanto for possível, apoiando a regra de não chamar atenção para
si. Ademais, o código fica mais legível e permite uma leitura mais agradável.

Além dos acentos, é exigido que as palavras-chave usadas sejam completas ou por
extenso, sem permitir abreviações (ex. ``proc'', ``func'', ``char'', ``int'',
...), o que dificulta a leitura de programas por um leigo.

Há também decisões quanto a forma verbal de comandos e funções. Em geral,
na literatura, os verbos nos algoritmos são expressos no imperativo, visto que
a linguagem é caracterizada como imperativa. Por outro lado, vale notar que,
mesmo em linguagens imperativas, é comum ver programas que utilizam
termos em português usando verbos no infinitivo.

Mesmo com essa perspectiva em vista, G-Portugol se utiliza de verbos no
imperativo para seus termos, de forma a se aproximar das formas utilizadas nas
literaturas sobre algoritmos.

\begin{quotation}
  \textit{``Programas devem ser escritos para pessoas lerem e, apenas incidentalmente, para máquinas executarem.''}
   \begin{flushright}
  -- Abelson e Sussman
  \end{flushright}
\end{quotation}

\subsubsection{A linguagem deve ser simples, uniforme e coerente}

Essa diretriz diz respeito a evitar excessões entre as formas gramaticais e
comportamentos semânticos na medida do possível. Isso significa não só que as
estruturas e comandos devem ser simples, claros e óbvios, como também, sua forma
e comportamento devem ter um princípio em comum, evidenciando um formato
uniforme. Naturalmente, a linguagem portugol já detém uma parcela relevante
de características que se acomodam nessas diretrizes, no entanto, alguns
detalhes ainda merecem atenção, como a representação de blocos estruturais.

A simplicidade implica em evitar complexidades que desviam a atenção do
propósito original para detalhes da linguagem. Isso é, apenas recursos
essenciais devem fazer parte de seu núcleo. Portanto, em um primeiro momento,
não é interessante equipar a linguagem com recursos como alocação dinâmica de
memória, controle de threads, etc.

\subsubsection{Deve ser configurável naquilo que diz respeito a
diferentes abordagens de ensino e estilo do professor}

Essa diretriz diz respeito a permitir que a linguagem mude em certos aspectos
(ou disponibilizar meios simples para realizar essas mudanças) de acordo com
o gosto do professor, ou como modo de adapatar a forma de portugol de uma
dada literatura. Dialetos e formas da linguagem portugol variam de
literatura para literatura, e pode ser interessante permitir que a linguagem se
adapte.

Entre os aspectos que podem ser adaptados com facilidade se encontram os
termos léxicos (palavras-chave, operadores,etc), e algumas formas de expressar
estruturas, como algumas declarações e enunciados.

Por exemplo, pode ser interessante que, para se declarar uma varíavel, não se
use um bloco iniciado por ``variáveis'' e terminado por ``fim-variáveis'', mas
como um bloco parecido com a declaração de variáveis em Pascal, ou até em C (que
sequer exige delimitação de bloco de variáveis).

\section{Formato Estrutural}

A forma de um programa escrito em G-Portugol tem o seguinte formato:

\begin{itemize}
 \item 
  declaração do algoritmo

  \item
  declaração de variáveis globais

  \item
  bloco principal

  \item
  declaração de funções
\end{itemize}

  A seguir, alguns pontos serão discutidos a respeito do formato da linguagem.

\subsection{Declaração do algoritmo}

A declaração do algoritmo não influencia o programa ou sua execução, visto que é
apenas uma sessão informativa no código que, embora não seja um comentário, tem
o mesmo efeito prático. A adoção dessa declaração pode ser discutida, e
foi escolhida por ser bastante utilizada em literaturas.
  
\subsection{Declaração de variáveis}

  Como visto no capítulo 2, essa declaração é opcional, e seu formato pode ser
visto no exemplo a seguir:

\begin{verbatim}
variáveis
  x : inteiro;
fim-variáveis
\end{verbatim}

Esse formato difere de linguagens como Pascal e C. Em Pascal, o bloco não tem um
delimitador final (como ``fim-variáveis'') e em C, não existe qualquer
delimitador.

Delimitar o bloco permite maior consistência com outras formas gramaticais
como os blocos de comando e estruturas de controle.

Os tipos primitivos englibam os tipos mais básicos das linguagens populares.
No momento, agregados heterogêneos como, por exemplo, estruturas/registros
(``struct'' em C) não são suportados.
  
\subsection{Bloco Principal}

As linguagens de programação devem, de alguma forma, oferecer um ``entry point''
(ponto de entrada), de onde se inicia a execução do programa. O ponto de entrada
pode ser uma função ou um bloco anônimo. Na literatura, em geral, o bloco
principal é delimitado pelos termos ``início''e ``fim''. Essa é uma abordagem
interessante que, em relação a uma função como ponto de entrada. Sendo assim,
G-Portugol se utiliza de ``início'' e ``fim'' como delimitadores do bloco
principal. Essa decisão mantém um nível satisfatório de coerência com o bloco de
variáveis globais e estruturas de controle, embora não sejam intimamente
relacionados.

Vale ressaltar que não se faz imposição sobre a identação do código. Esse
recurso pode ser vantajoso no ensino, promovendo a clareza de código,
portanto, sua implementação pode ser discutida para versões futuras.

  \subsubsection{Estruturas de Controle}

Estruturas de controle são formadas por um cabeçalho seguido por
um bloco de comandos e terminados por um delimitador final. Embora os
delimitadores do bloco não sejam ``início'' e ``fim'', há um grau de semelhança
mantido: o delimitador inicial é omitido (uma vez que o cabeçalho é entendido
como delimitador inicial) e o delimitador final é o termo ``fim-'' seguido do
nome da estrutura.

No cabeçalho das estruturas como ``enquanto'' e ``se'', as expressões não
precisam ser delimitadas por parêntesis.


  \subsubsection{Expressões}
  \label{sec:expr}

Expressões são operações que sintetizam, ao final, um valor. Em geral
constituem valores ou operações aritiméticas com um ou mais termos que podem
ser variáveis, constantes ou chamadas a funções e são usadas em atribuições,
estruturas de controle e subscritos de matrizes e vetores. Enunciados (como
atribuições) não podem ser avaliados como expressões.

Constantes são valores \textit{inline}, e cada tipo de dado tem uma forma de
ser representada.

\begin{itemize}
 \item 
  Inteiros: Podem ser representados em base decimal, hexadecimal, octal e
binária. Representações decimais são formadas por um ou mais algarismos (ex.
``120''). Representações hexadecimais são representadas com o prefixo ``0x'' ou
`` 0X'', seguido de algarismos entre ``0'' e ``9'' e letras entre ``a'' e ``f''
ou ``A'' e ``F'' (ex. ``0xF1A5''). Representações octais são representadas com o
prefixo ``0c'' ou ``0C'', seguido de algarismos entre ``0'' e ``7'' (ex.
``0c61''). Finalmente, representações binárias são formadas pelo prefixo ``0b''
ou ``0B'', seguido de algarismos ``0'' e ``1'' (ex. ``0b101'').

  \item
  Reais: são representados por algarismos separados por um ``.'' como ``2.5''.

  \item
  Caracteres: são representados por um único simbolo entre aspas simples.
Alguns caracteres especiais são representados com escape (``$\backslash$'')
seguido de símbolo identificador. Esses caracteres são o LF (``$\backslash$n''),
CR (``$\backslash$r'') e barra invertida (``$\backslash$$\backslash$''). A
ausência de símbolos entre as aspas simples indica um caractere ``nulo''.
Internamente, caracteres são representados como números inteiros, o que permite
sua compatibilidade numérica.

  \item
  Literais: são representados por um conjunto de caracteres entre aspas duplas.
Eles podem conter caracteres especiais (como CR) e devem ser definidos em
apenas uma linha de código. Valores literais são os únicos que não tem uma
representação numérica, o que permitira sua participação em expressões com
operadores aritméticos (soma, divisão, AND, etc).

  \Lógicos: são representados por ``verdadeiro'' e ``falso''. Numericamente,
qualquer valor diferente de ``0'' representa o valor verdadeiro e ``0''
representa o valor falso.

\end{itemize}

A precedencia de operadores é mostrada na tabela \ref{tb_precedencia_op} (da
menor precedência para a maior) e pode ser expliticamente modificada com o uso
de parêntesis.


\begin{table}[ht]
\begin{center}
  \begin{tabular}{|l|l|}
    \hline
    \multicolumn{2}{|c|}{Precedência de Operadores} \\
    \hline
      Operador & Nome \\
    \hline
    ou, ||          & OR lógico  \\
    e, \&\&         & AND lógico \\
    |               & OR binário \\
    \^{}            &  XOR binário \\
    \&              & AND binário \\
    =, <>           & operadores de igualdade \\
    >, >=, <, <=    & operadores relacionais \\
    +, -            & operadores aritméticos soma e subtração \\
    \symbol{42}, /, \%     & operadores aritméticos multiplicação,
divisão, módulo \\
    +, -, \~{}, não & operadores unários positivo, negativo, NOT binário, NOT
lógico \\
    \hline
  \end{tabular}
  \label{tb_tipos_primitivos}
  \caption{Precedência de Operadores \label{tb_precedencia_op}}
\end{center}
\end{table}


Em G-Portugol, não há coerção ou \textit{casting} de tipos expliticamente.
Todos os tipos numéricos (inteiro, real, lógico e caractere) são compativeis
entre si.

Existem dois casos em que ocorre uma coerção implicita. O primeiro caso ocorre
durante a avaliação de uma expressão que tem operandos de tipos diferentes (mas
compatíveis entre si), mas não há perda de dados. O segundo caso é discutido na
seção \ref{subsec:atribuicoes}.



  \subsection{Atribuições}

Atribuições permitem a manipulação de valores na memória. Em G-Portugol,
como já foi visto, é usado o operador ``:='', onde o termo a esquerda ou
``\textit{lvalue}'' deve ser uma variável primitiva ou indice de uma
matriz/vetor, e o termo a esquerda, uma expressão que, quando avaliada, tem seu
tipo compatível com o \textit{lvalue}.

Pode haver coerção de tipos durante a atribuição, quando o resultado da
expressão é de um tipo diferente (mas compatível) do tipo de \textit{lvalue}.
É possível que dados sejam comprometidos, por exemplo, tendo uma expressão
avaliada como real sendo atribuida a uma variável de tipo inteiro (o valor será
truncado).

Matrizes não são aceitas como \textit{lvalue}, como pode ser visto no programa
\ref{bad_matrix}.

\begin{program}
  \begin{verbatim}
algoritmo bad_matrix;

variáveis
  m1 : matriz[2] de inteiros;
  m2 : matriz[2] de inteiros;
fim-variáveis

início
  m1 := m2;    //erro
  imprima(m1); //erro
fim
  \end{verbatim}
  
  \caption{Uso incorreto de matrizes. \label{bad_matrix}}
\end{program}


\section{Funções}

Funções são os subprogramas de G-Portugol. São definidas após o bloco principal
e podem receber argumentos e retornar valores. Em tempo de execução, as funções
criam um novo escopo sobreposto ao escopo principal. Isso permite recursos
como recursão e possibilita que variáveis locais (no escopo da função) tenham o
mesmo nome que variáveis globais, onde essas últimas ficam ``escondidas'', isso
é, incapazes de serem acessadas enquanto o escopo durar. Ressalta-se que não há
suporte para funções aninhadas, isso é, funções declaradas dentro de funções. 

O retorno de dados é feito por meio da instrução ``retorne'' e o valor de
retorno (se houver) deve ser compatível com o tipo da função. Esse tipo não
pode ser um tipo agregado como matrizes e vetores.

Tanto a passagem de argumentos quanto o retorno é feito \textit{por valor},
isso é, a copia do valor é feita, ao invez de a copia de endereço ou passagem
\textit{por referência}.

As variáveis locais de uma função são formadas por seus parâmetros e pelas
variáveis declaradas em seu escopo. A declaração de variáveis locais é feita
entre o cabeçalho da função e a palavra-chave ``início'', portanto, não é
uniforme em relação a declaração global, onde se usa as palavras-chave
``variáveis'' e ``fim-variáveis''. 

A declaração dos parâmetros da função também não segue estritamente o formato
de declaração de variáveis. Sua definição pode ser vista no capítulo *todo*.
%capitulo da gramatica


\section {Funções internas}

G-Portugol oferece duas funções internas para manipulação básica de entrada e
saída. Ambas as funções tem comportamentos excepcionais quando comparadas
com as funções de usuário. Essas funções são discutidas na sessão a seguir.

  \subsection{A função ``imprima''}

A função imprima tem como objetivo imprimir texto no dispositivo de saída.
Ela recebe um número variável de argumentos (pelo menos um), onde cada
argumento deve ser um valor primitivo, e os imprime em sequencia. Ao final, é
impresso um caractere de nova linha (LF) e a função retorna.

Essa função se comporta de forma excepcional visto que não é
possível declarar funções em G-Portugol que recebem um número variável de
argumentos.



  \subsection{A função ``leia''}

A função ``leia'' espera por uma entrada do teclado seguida do caractere LF (em
geral, associado a tecla ``Enter'') e retorna o valor lido. Esse valor é
convertido implicitamente para o tipo do \textit{lvalue}. Alguns exemplos de
conversões podem ser vistos na tabela \ref{tb_conv_leia}:

\begin{table}[ht]
\begin{center}
  \begin{tabular}{|l|l|l|}
    \hline
    \multicolumn{3}{|c|}{Conversões da função ``leia''} \\
    \hline
      Tipo Esperado & Texto lido & Valor convertido \\
      inteiro & ``123'' & 123 \\
      inteiro & ``123 456'' & 123 \\
      inteiro & ``abc'' & 0 \\
      inteiro & ``123s'' & 123 \\
      lógico  & ``falso'' & falso \\
      lógico & ``0'' & falso \\
      lógico & ``falso 12wtc'' & verdadeiro \\
      lógico & ``0 umdois3'' & verdadeiro\\
    \hline
  \end{tabular}
  \label{tb_tipos_primitivos}
  \caption{Conversões implícitas da função ``leia'' \label{tb_conv_leia}}
\end{center}
\end{table}


Essa função se comporta de forma excepcional visto que seu tipo de retorno não
é absoluto (depende do tipo de \textit{lvalue}) e é restrita expressões isentas
de operadores. Isso é, não é permitido aplicá-la a operadores em expressões,
embora seja possível utilizá-la em subscritos de vetores e matrizes, assim como
em expressões de estruturas de controle. 

Em princípio, pode-se levar em conta duas formas de implementar uma função de
leitura. A primeira, e mais simples é o uso de funções sobrecarregadas, que
não retornam valor e recebem um parâmetro de certo tipo, que é alimentado com o
valor lido. Essa forma exige que a passagem seja feita por referência. A outra
forma, é a implementada em G-Portugol, onde a função não recebe parâmetros e
retorna o valor lido.

As duas formas exigem comportamentos excepcionais, visto que G-Portugol não tem
recursos suficientes para compreender sobrecarga de funções ou passagem de
parâmetros por referência.


\capitulo{O programa GPT}

\section{Intrudução}
  
  
  traducao (C)
  interpretacao/depuracao
  compilacao (ELF)

  Comportamento uniforme entre os tipos de execução
    *traducao, compilacao e interpretacao devem ter o mesmo comportamento 

\section{Opções gerais}

  *versão e ajuda.

  *mudanca de linguagem (sub linguagens, variacoes de gramatica) (nao
implementado ainda)

  

\section{Tratamento de erros}
  
  *opcao para mais verbose (-d: dicas)

  *sobre o tratamento de erros. 
    -Importancia de ``verbose''

	tratamento de erros:
será que atrapalha mais do que ajuda continuar a analise sintatica apos errors encontrados?
Muitos erros seguintes ao primeiro podem acabar atrapalhando mais.
Ao catch[], pode-se lancar um custom exception, a ser recuperado em main.c
Fazer disso uma opcao?
A dificuldade em deixar as mensagens de erro uniformes, ao tentar elaborar tratamentos de erros mais detalhados e prestativos.

\section{Geração Execução de programas}

\subsection{Tradução para C}

  *opcao -t

  \subsubsection{Limitações}
      *nomes de identificadores em conflito com os nomes em C/glibc

	*diferencas:
		*array bound check
		*precedencia de operadores de C vs. precendencia de operadores de G-Portugol (pesquisar para saber se sao equivalentes)

\subsection{Interpretação de código}

  *opcao -i

  \subsubsection{Erros de execução (runtime errors)}
    boundcheck, etc...

  \subsubsection{Depuração interativa}

      *estrutura do XML
      *command line debugger.

\subsection{Compilação para codigo nativo (ELF)}

  *opcao default

  
%%%
%  Apendice
%   *gramatica da linguagem
%%%

\end{document}
